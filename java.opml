<?xml version="1.0" encoding="UTF-8"?><opml>  <head>    <title></title>    <dateModified></dateModified>    <ownerName></ownerName>  </head>  <body>    <outline text="# Java" 栏2="第一行&#10;第二行&#10;第四行&#10;">      <outline text="#### 我就是四级菜单"/>      <outline text="## 1)环境">        <outline text="### Java简介"/>        <outline text="### JDK的安装与配置"/>        <outline text="### 1.1)命令" _note="参考文档：https://blog.csdn.net/yang889999888/article/details/72823261&#10;">          <outline text="#### 1.1.1)java" _note="运行java程序。&#10;"/>          <outline text="#### 1.1.2)javac" _note="编译的Java程序，生成.class文件。&#10;"/>          <outline text="#### 1.1.3)javaw" _note="跟java命令相对的，可以运行.class文件,主要用来执行图形界面的java程序运行java命令时，会出现并保持一个console窗口,程 序中的信息可以通过System.out在console内输出，而运行javaw，开始时会出现console，当主程序调用之后，console就会 消失； javaw 大多用来运行GUI程序。&#10;"/>          <outline text="#### 1.1.4)javah" _note="C 头文件和 Stub 文件生成器。javah 从 Java 类生成 C 头文件和 C 源文件。这些文件提供了连接胶合，使 Java 和 C 代码可进行交互。&#10;"/>          <outline text="#### 1.1.5)javap" _note="用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。&#10;"/>          <outline text="#### 1.1.6)jdb" _note="命令行调试环境，既可在本地，也可在与远程的解释器的一次对话中执行。&#10;"/>          <outline text="#### 1.1.7)javaws" _note="应用程序高速缓存查看器。&#10;"/>          <outline text="#### 1.1.8)jconsole" _note="Java监视和管理控制台,JConsole使用JVM的可扩展性Java管理扩展(JMX)工具来提供关于运行于Java平台的应用程序的性能和资源消耗的信息。&#10;"/>          <outline text="#### 1.1.9)jps" _note="java虚拟机进程状态工具---在目标系统上列出装备有HotSpot Java的虚拟机。&#10;"/>          <outline text="#### 1.1.10)jstat" _note="JVM监控工具,java虚拟机统计监视工具---附加到一个装备了HotSpot的java虚拟机上来采集并且记录性能统计情况。&#10;"/>          <outline text="#### 1.1.11)jstatd" _note="java虚拟机的jstat守护程序---启动一个RMI服务器程序来监视各个HotSpot java虚拟机的创建和中止。并且提供了一个访问远程监视工具接入的接口。&#10;"/>          <outline text="#### 1.1.12)kinit" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.13)klist" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.14)ktab" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.15)native2ascii" _note="将含有本地编码字符（既非 Latin1 又非 Unicode 字符）的文件转换为 Unicode 编码字符的文件。&#10;"/>          <outline text="#### 1.1.16)ordb"/>          <outline text="#### 1.1.17)idlj"/>          <outline text="#### 1.1.18)servertool"/>          <outline text="#### 1.1.19)tnameserv"/>          <outline text="#### 1.1.20)"/>        </outline>        <outline text="### 1.2)javadoc"/>        <outline text="### 1.3)IDE">          <outline text="#### 1.3.1)Eclipse"/>          <outline text="#### 1.3.2)IDEA"/>          <outline text="#### 1.3.3)NetBeans"/>        </outline>        <outline text="### 1.4)版本管理">          <outline text="#### 1.4.1)SVN"/>          <outline text="#### 1.4.2)Git"/>        </outline>      </outline>      <outline text="## 2)基础语法">        <outline text="### 2.1)数据类型">          <outline text="#### 2.1.1)数据类型清单">            <outline text="##### 2.1.1.1)整形/int"/>            <outline text="##### 2.1.1.2)浮点型/float"/>            <outline text="##### 2.1.1.3)字符型/char"/>            <outline text="##### 2.1.1.4)布尔型/boolean"/>          </outline>          <outline text="#### 2.1.2)标识符">            <outline text="##### 2.1.2.1)变量"/>            <outline text="##### 2.1.2.2)常量"/>          </outline>          <outline text="#### 2.1.3)关键字">            <outline text="##### 2.1.3.1)private" _note="&#10;| 关键字          | 同一个包中的其他类 | 不同包中的其他类 | 子类   | 自身   |&#10;| ------------ | --------- | -------- | ---- | ---- |&#10;| private      | No        | No       | No   | Yes  |&#10;| protected    | Yes       | No       | Yes  | Yes  |&#10;| public       | Yes       | Yes      | Yes  | Yes  |&#10;| 无修饰（default） | Yes       | No       | No   | Yes  |&#10;"/>            <outline text="##### 2.1.3.2)public"/>            <outline text="##### 2.1.3.3)protected"/>            <outline text="##### 2.1.3.4)default"/>            <outline text="##### 2.1.3.5)static" _note="&#10;static关键字修饰内容的几个特点：&#10;1. static修饰的变量和类文件一同被加载到内存中&#10;2. 被修饰的方法可以直接通过类名加点来引用，也就是说static修饰部分的引用是不需要将对象实例化的。&#10;    有关static一些**注意事项**：&#10;- static方法只能访问static变量&#10;- static方法中不能使用this,super这样的关键字，因为static优先于对象被加载到内存之中，static执行时对象可能还未被实例化。&#10;- 内部类包含static修饰的属性或方法时，内部类必须也被static修饰，其实理解起来也很简答，应为static会优先被加载，如果内部类不被static修饰，那么内部变量是不会被提前加载的，这时static关键字修饰就不起作用了。&#10;"/>            <outline text="##### 2.1.3.6)final" _note="&#10;- final是一个修饰词，可修饰类，变量，函数&#10;- final修饰的类不可被继承&#10;- final修饰的函数无法被复写&#10;- final修饰的变量只能赋值一次&#10;"/>            <outline text="##### 2.1.3.7)abstract" _note="&#10;- abstract能够修饰方法和类&#10;- abstract修饰的类无法被实例化，只能够通过子类的继承并实现内部所有的抽象函数才能被实例化。&#10;- abstract修饰的函数只需要申明方法名，参数，不需要写函数体。&#10;- 抽象类中同样可以定义非抽象的方法，同时抽象类也有构造函数，这个构造函数提供给子类实例化时使用。&#10;- 抽象类中也可以没有抽象的方法。&#10;- abstract不可以和static，private，final公用，简单理解一下，static修饰说明优先加载，而abstract未被实现，所以无法被优先加载。final修饰表名为最终状态无法修改，而abstract修饰的需要子类去实现，必须可以修改。private表示私有化，自由自身能够访问到，而abstract需要子类访问并实现函数体。&#10;"/>            <outline text="##### 2.1.3.8)instanceof" _note="用于判断类是否实现了指定接口或实现了指定的类，举个简单的例子：&#10;```java&#10;public class Test {&#10;    public static void main(String[] args) {&#10;        NullPointerException e = new NullPointerException();&#10;        System.out.println(e instanceof Exception);&#10;    }&#10;}&#10;//输出结果为true&#10;```&#10;"/>          </outline>          <outline text="#### 2.1.4)类型转换"/>          <outline text="#### 2.1.5)数组"/>          <outline text="#### 2.1.6)枚举"/>        </outline>        <outline text="### 2.2)运算操作">          <outline text="#### 2.2.1)表达式"/>          <outline text="#### 2.2.2)分隔符"/>          <outline text="#### 2.2.3)运算符"/>        </outline>        <outline text="### 2.3)语句控制">          <outline text="#### 2.3.1)循环语句"/>          <outline text="#### 2.3.2)条件语句"/>          <outline text="#### 2.3.3)跳转语句"/>          <outline text="#### 2.3.4)其他语句"/>        </outline>        <outline text="### 2.4)注释"/>        <outline text="### 2.5)修饰符"/>      </outline>      <outline text="## 3)常用基础类库">        <outline text="### 3.1)lang"/>        <outline text="### 3.2)collections"/>        <outline text="### 3.3)io"/>        <outline text="### 3.4)net"/>      </outline>      <outline text="## 4)OOP">        <outline text="### 4.1)OOP思想">          <outline text="#### 4.1.1)封装"/>          <outline text="#### 4.1.2)继承"/>          <outline text="#### 4.1.3)多态"/>        </outline>        <outline text="### 4.2)类与对象">          <outline text="#### 4.2.1)Object类"/>          <outline text="#### 4.2.2)Class类"/>          <outline text="#### 4.2.3)抽象类"/>          <outline text="#### 4.2.4)接口"/>          <outline text="#### 4.2.5)匿名内部类"/>          <outline text="#### 4.2.6)包装类"/>        </outline>        <outline text="### 4.3)类的行为">          <outline text="#### 4.3)构造方法"/>          <outline text="#### 4.3.1)重载(Overload)" _note="&#10;（1） 方法重载是让类以**统一的方式处理不同类型数据**的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。&#10;（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。&#10;（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。&#10;（4） 返回值是方法执行后的结果，我们在调用方法的时候不会指定说“我要调用返回值是xxx类型的方法”，它不成成为方法重载的特征。&#10;（5） 重载的标志：方法名相同，参数不同（个数或者类型），与返回值无关。&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，编译器多态。&#10;**重载的规则：**&#10;1、必须具有不同的参数列表；&#10;2、可以有不责骂的返回类型，只要参数列表不同就可以了；&#10;3、可以有不同的访问修饰符；&#10;4、可以抛出不同的异常；&#10;5、当需要在子类中调用父类的被重写方法时，要使用super关键字。&#10;```java&#10;public class OverloadParent{&#10;  public String getPerson(String name){&#10;    return “personA” + name;&#10;  }&#10;  public String getPerson(int age){&#10;    return “personB” ;&#10;  }&#10;  public String getPerson(String name,int age){&#10;    return “personC”;&#10;  }&#10;  public void getPerson(String name){&#10;    System.out.println(“我是重载的方法吗？”);&#10;  }&#10;}&#10;public class OverloadChildextends OverloadParent {&#10;  public void getPerson(double money){&#10;     Sytem.out.println(“我是重载的方法吗”);&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.2)覆写(Override)" _note="&#10;（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。&#10;但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。&#10;方法覆写又称方法覆盖。&#10;（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。&#10;（3）子类函数的访问修饰权限不能少于父类的；&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，运行期多态。&#10;**覆写方法的规则：**&#10;1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。&#10;2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。&#10;3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）&#10;4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：&#10;父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。&#10;覆写与重载的区别在于：&#10;覆写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。&#10;```java&#10;public class OverrideParent{&#10;   public void fly(){&#10;     System.out.println(“Ican fly!”);&#10;  }&#10;}&#10;public class OverrideChild extends OverrideParent{&#10;  @override&#10;  public void fly(){&#10;       System.out.println(“Ican not fly, but I can run!”);&#10;  }&#10;  public static vid main(String[] args){&#10;       OverwriteParent child= new OverwriteChild();&#10;       child.fly();&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.3)泛型"/>          <outline text="#### 4.3.4)反射"/>        </outline>      </outline>      <outline text="## 5)高级语法">        <outline text="### 5.1)字符串">          <outline text="#### 5.1.1)String"/>          <outline text="#### 5.1.2)StringBuilder"/>          <outline text="#### 5.1.3)StringBuffer"/>        </outline>        <outline text="### 5.2)异常"/>        <outline text="### 5.3)集合">          <outline text="#### 5.3.1)List"/>          <outline text="#### 5.3.2)Set"/>          <outline text="#### 5.3.3)Map"/>          <outline text="#### 5.3.4)数组"/>        </outline>        <outline text="### 5.4)可变参数"/>        <outline text="### 5.5)静态导入"/>        <outline text="### 5.6)Annotation"/>        <outline text="### 5.7)Lambda"/>        <outline text="### 5.8)正则表达式">          <outline text="#### 5.8.1)Regex"/>        </outline>        <outline text="### 5.9)JDBC">          <outline text="#### 5.9.1.)JDBC基础"/>          <outline text="#### 5.9.2)连接池技术"/>          <outline text="#### 5.9.3)jdbc的dao封装"/>        </outline>        <outline text="### 5.10)JVM">          <outline text="#### 5.10.1)内存"/>          <outline text="#### 5.10.2)GC"/>        </outline>        <outline text="### 5.11)多线程">          <outline text="#### 5.11.1)线程池"/>          <outline text="#### 5.11.2)线程安全集合"/>          <outline text="#### 5.11.3)线程锁"/>        </outline>        <outline text="### 5.12)国际化">          <outline text="#### 5.12.1)字符集"/>        </outline>        <outline text="### 5.13)比较器"/>        <outline text="### 5.14)文件与流">          <outline text="#### 5.14.1)文件操作类"/>          <outline text="#### 5.14.2)字节流与字符流">            <outline text="##### 5.14.2.1)文件的读入"/>            <outline text="##### 5.14.2.1.1)按字节读取文件内容" _note="```java&#10;public static void readFileByBytes(String fileName) {&#10;    File file = new File(fileName);&#10;    InputStream in = null;&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);&#10;        // 一次读一个字节&#10;        in = new FileInputStream(file);&#10;        int tempbyte;&#10;        while ((tempbyte = in.read()) != -1) {&#10;            System.out.write(tempbyte);&#10;        }&#10;        in.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;        return;&#10;    }&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读多个字节：&quot;);&#10;        // 一次读多个字节&#10;        byte[] tempbytes = new byte[100];&#10;        int byteread = 0;&#10;        in = new FileInputStream(fileName);&#10;        ReadFromFile.showAvailableBytes(in);&#10;        // 读入多个字节到字节数组中，byteread为一次读入的字节数&#10;        while ((byteread = in.read(tempbytes)) != -1) {&#10;            System.out.write(tempbytes, 0, byteread);&#10;        }&#10;    } catch (Exception e1) {&#10;        e1.printStackTrace();&#10;    } finally {&#10;        if (in != null) {&#10;            try {&#10;                in.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;private static void showAvailableBytes(InputStream in) {&#10;    try {&#10;        System.out.println(&quot;当前字节输入流中的字节数为:&quot; + in.available());&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.2)按字符读取文件内容" _note="```java&#10;public static void readFileByChars(String fileName) {&#10;     File file = new File(fileName);&#10;     Reader reader = null;&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读一个字节：&quot;);&#10;         // 一次读一个字符&#10;         reader = new InputStreamReader(new FileInputStream(file));&#10;         int tempchar;&#10;         while ((tempchar = reader.read()) != -1) {&#10;             // 对于windows下，\r\n这两个字符在一起时，表示一个换行。&#10;             // 但如果这两个字符分开显示时，会换两次行。&#10;             // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。&#10;             if (((char) tempchar) != '\r') {&#10;                 System.out.print((char) tempchar);&#10;             }&#10;         }&#10;         reader.close();&#10;     } catch (Exception e) {&#10;         e.printStackTrace();&#10;     }&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读多个字节：&quot;);&#10;         // 一次读多个字符&#10;         char[] tempchars = new char[30];&#10;         int charread = 0;&#10;         reader = new InputStreamReader(new FileInputStream(fileName));&#10;         // 读入多个字符到字符数组中，charread为一次读取字符数&#10;         while ((charread = reader.read(tempchars)) != -1) {&#10;             // 同样屏蔽掉\r不显示&#10;             if ((charread == tempchars.length) &amp;&amp; (tempchars[tempchars.length - 1] != '\r')) {&#10;                  System.out.print(tempchars);&#10;             } else {&#10;                 for (int i = 0; i &lt; charread; i++) {&#10;                     if (tempchars[i] == '\r') {&#10;                         continue;&#10;                     } else {&#10;                         System.out.print(tempchars[i]);&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (Exception e1) {&#10;         e1.printStackTrace();&#10;     } finally {&#10;         if (reader != null) {&#10;             try {&#10;                 reader.close();&#10;             } catch (IOException e1) {&#10;             }&#10;         }&#10;     }&#10; }&#10;```&#10;"/>            <outline text="##### 5.14.2.1.3)按行读取文件内容" _note="```java&#10;public static void readFileByLines(String fileName) {&#10;    File file = new File(fileName);&#10;    BufferedReader reader = null;&#10;    try {&#10;        System.out.println(&quot;以行为单位读取文件内容，一次读一整行：&quot;);&#10;        reader = new BufferedReader(new FileReader(file));&#10;        String tempString = null;&#10;        int line = 1;&#10;        // 一次读入一行，直到读入null为文件结束&#10;        while ((tempString = reader.readLine()) != null) {&#10;            // 显示行号&#10;            System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);&#10;            line++;&#10;        }&#10;        reader.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (reader != null) {&#10;            try {&#10;                reader.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.4)随机读取文件内容" _note="```java&#10;public static void readFileByRandomAccess(String fileName) {&#10;    RandomAccessFile randomFile = null;&#10;    try {&#10;        System.out.println(&quot;随机读取一段文件内容：&quot;);&#10;        // 打开一个随机访问文件流，按只读方式&#10;        randomFile = new RandomAccessFile(fileName, &quot;r&quot;);&#10;        // 文件长度，字节数&#10;        long fileLength = randomFile.length();&#10;        // 读文件的起始位置&#10;        int beginIndex = (fileLength &gt; 4) ? 4 : 0;&#10;        // 将读文件的开始位置移到beginIndex位置。&#10;        randomFile.seek(beginIndex);&#10;        byte[] bytes = new byte[10];&#10;        int byteread = 0;&#10;        // 一次读10个字节，如果文件内容不足10个字节，则读剩下的字节。&#10;        // 将一次读取的字节数赋给byteread&#10;        while ((byteread = randomFile.read(bytes)) != -1) {&#10;            System.out.write(bytes, 0, byteread);&#10;        }&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (randomFile != null) {&#10;            try {&#10;                randomFile.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.2)文件的写入"/>            <outline text="##### 5.14.2.2.1)FileWritter写入文件" _note="```java&#10;public static void main( String[] args ){&#10;　　   try{&#10;　　         String data = &quot; This content will append to the end of the file&quot;;&#10;　　         File file =new File(&quot;javaio-appendfile.txt&quot;);&#10;　　         //if file doesnt exists, then create it&#10;　　         if(!file.exists()){&#10;　　              file.createNewFile();&#10;　　          }&#10;　　         //true = append file&#10;　　         FileWriter fileWritter = new FileWriter(file.getName(),true);&#10;　　         BufferedWriter bufferWritter = new BufferedWriter(fileWritter);&#10;　　         bufferWritter.write(data);&#10;　　         bufferWritter.close();&#10;　　         System.out.println(&quot;Done&quot;);&#10;　　   }catch(IOException e){&#10;　　        e.printStackTrace();&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.2)BufferedWriter写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    try {&#10;　　        String content = &quot;This is the content to write into file&quot;;&#10;　　        File file = new File(&quot;/users/mkyong/filename.txt&quot;);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　           file.createNewFile();&#10;　　       }&#10;　　       FileWriter fw = new FileWriter(file.getAbsoluteFile());&#10;　　       BufferedWriter bw = new BufferedWriter(fw);&#10;　　       bw.write(content);&#10;　　       bw.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　    } catch (IOException e) {&#10;　　         e.printStackTrace();&#10;　　    }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.3)FileOutputStream写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    FileOutputStream fop = null;&#10;　　    File file;&#10;　　    String content = &quot;This is the text content&quot;;&#10;　　    try {&#10;　　        file = new File(&quot;c:/newfile.txt&quot;);&#10;　　        fop = new FileOutputStream(file);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　            file.createNewFile();&#10;　　       }&#10;　　       // get the content in bytes&#10;　　       byte[] contentInBytes = content.getBytes();&#10;　　       fop.write(contentInBytes);&#10;　　       fop.flush();&#10;　　       fop.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　   } catch (IOException e) {&#10;　　       e.printStackTrace();&#10;　　   } finally {&#10;　　       try {&#10;　　           if (fop != null) {&#10;　　               fop.close();&#10;　　           }&#10;　　       } catch (IOException e) {&#10;　　             e.printStackTrace();&#10;　　       }&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.4)几种方法的比较" _note="相对而言，FileWritter最快，FileOutputStream最慢&#10;"/>          </outline>        </outline>        <outline text="### 5.15)序列化"/>      </outline>      <outline text="## 6)开源专题">        <outline text="### 6.1)Log">          <outline text="#### 6.1.1)Log4j"/>          <outline text="#### 6.1.2)SLF4J"/>        </outline>        <outline text="### 6.2)ORM">          <outline text="#### 6.2.1)Hibernate"/>          <outline text="#### 6.2.2)MyBatis">            <outline text="##### 6.2.2.1)1.mybatis简介"/>            <outline text="##### 6.2.2.2)2.基本增删改查"/>            <outline text="##### 6.2.2.3)3.注解方式实现"/>            <outline text="##### 6.2.2.4)4.动态SQL"/>            <outline text="##### 6.2.2.5)5.多种参数传递"/>            <outline text="##### 6.2.2.6)6.一对一"/>            <outline text="##### 6.2.2).77.一对多"/>            <outline text="##### 6.2.2.8)8.多对多"/>          </outline>        </outline>        <outline text="### 6.3)Test">          <outline text="#### 6.3.1)JUnit"/>        </outline>        <outline text="### 6.4)Build">          <outline text="#### 6.4.1)Ant"/>          <outline text="#### 6.4.2)Maven"/>          <outline text="#### 6.4.3)Gradle"/>        </outline>        <outline text="### 6.5)脚本语言">          <outline text="#### 6.5.1)Groovy"/>          <outline text="#### 6.5.2)velocity"/>        </outline>        <outline text="### 6.6)Spring">          <outline text="#### 6.6.1)SpringCore">            <outline text="##### 6.6.1.2)01.了解Spring"/>            <outline text="##### 6.6.1.2)02.IOC思想"/>            <outline text="##### 6.6.1.3)03.DI依赖注入"/>            <outline text="##### 6.6.1.4)04.控制反转"/>            <outline text="##### 6.6.1.5)05.代理"/>            <outline text="##### 6.6.1.6)06.事务管理"/>            <outline text="##### 6.6.1.7)07.Bean生命周期"/>            <outline text="##### 6.6.1.8)08.集合注入"/>            <outline text="##### 6.6.1.9)09.AOP概念"/>            <outline text="##### 6.6.1.10)10.Spring注解"/>          </outline>          <outline text="#### 6.6.2)SpringMVC">            <outline text="##### 6.6.2.1)SpringMVC简介"/>            <outline text="##### 6.6.2.2)handleMapping"/>            <outline text="##### 6.6.2.3)RequestMapping"/>            <outline text="##### 6.6.2.4)SpringMVC参数传递"/>            <outline text="##### 6.6.2.5)返回页面数据"/>            <outline text="##### 6.6.2.6)适配器"/>            <outline text="##### 6.6.2.7)拦截器"/>            <outline text="##### 6.6.2.8)视图与模型"/>            <outline text="##### 6.6.2.9)上传文件"/>            <outline text="##### 6.6.2.10)AJAX的使用"/>            <outline text="##### 6.6.2.11)SpringMVC与Struts区别"/>          </outline>          <outline text="#### 6.6.3)SpringBoost"/>        </outline>        <outline text="### 6.7)前端技术"/>        <outline text="### 6.8)XML">          <outline text="#### 6.8.1)Dom4j"/>        </outline>        <outline text="### 6.9)配置文件"/>      </outline>      <outline text="## 7)算法与设计模式">        <outline text="### 7.1)设计模式">          <outline text="#### 7.1.1)GOF">            <outline text="##### 7.1.1.1)创建型">              <outline text="###### 7.1.1.1.1)Factory Method（工厂方法）"/>              <outline text="###### 7.1.1.1.2)Abstract Factory（抽象工厂）"/>              <outline text="###### 7.1.1.1.3)Builder（建造者）"/>              <outline text="###### 7.1.1.1.4)Prototype（原型）"/>              <outline text="###### 7.1.1.1.5)Singleton（单例）"/>            </outline>            <outline text="##### 7.1.1.2)结构型">              <outline text="###### 7.1.1.2.1)Adapter Class/Object（适配器）"/>              <outline text="###### 7.1.1.2.2)Bridge（桥接）"/>              <outline text="###### 7.1.1.2.3)Composite（组合）"/>              <outline text="###### 7.1.1.2.4)Decorator（装饰）"/>              <outline text="###### 7.1.1.2.5)Facade（外观）"/>              <outline text="###### 7.1.1.2.6)Flyweight（享元）"/>              <outline text="###### 7.1.1.2.7)Proxy（代理）"/>            </outline>            <outline text="##### 7.1.1.3)行为型">              <outline text="###### 7.1.1.3.1)Interpreter（解释器）"/>              <outline text="###### 7.1.1.3.2)Template Method（模板方法）"/>              <outline text="###### 7.1.1.3.3)Chain of Responsibility（责任链）"/>              <outline text="###### 7.1.1.3.4)Command（命令）"/>              <outline text="###### 7.1.1.3.5)Iterator（迭代器）"/>              <outline text="###### 7.1.1.3.6)Mediator（中介者）"/>              <outline text="###### 7.1.1.3.7)Memento（备忘录）"/>              <outline text="###### 7.1.1.3.8)Observer（观察者）"/>              <outline text="###### 7.1.1.3.9)State（状态）"/>              <outline text="###### 7.1.1.3.10)Strategy（策略）"/>              <outline text="###### 7.1.1.3.11)Visitor（访问者）"/>            </outline>          </outline>          <outline text="#### 7.1.2)六大原则">            <outline text="##### 7.1.2.1)1、开闭原则（Open Close Principle）"/>            <outline text="##### 7.1.2.2)2、里氏代换原则（Liskov Substitution Principle）"/>            <outline text="##### 7.1.2.3)3、依赖倒转原则（Dependence Inversion Principle）"/>            <outline text="##### 7.1.2.4)4、接口隔离原则（Interface Segregation Principle）"/>            <outline text="##### 7.1.2.5)5、迪米特法则（最少知道原则）（Demeter Principle）"/>            <outline text="##### 7.1.2.6)6、合成复用原则（Composite Reuse Principle）"/>          </outline>        </outline>        <outline text="### 7.2)算法">          <outline text="#### 7.2.1)算法（第四版）"/>        </outline>      </outline>      <outline text="## 8)项目"/>      <outline text="## 9)试题"/>      <outline text="## 0)文化"/>    </outline>  </body></opml><?xml version="1.0" encoding="UTF-8"?><opml>  <head>    <title></title>    <dateModified></dateModified>    <ownerName></ownerName>  </head>  <body>    <outline text="# Java" 栏2="第一行&#10;第二行&#10;第四行&#10;">      <outline text="#### 我就是四级菜单"/>      <outline text="## 1)环境">        <outline text="### Java简介"/>        <outline text="### JDK的安装与配置"/>        <outline text="### 1.1)命令" _note="参考文档：https://blog.csdn.net/yang889999888/article/details/72823261&#10;">          <outline text="#### 1.1.1)java" _note="运行java程序。&#10;"/>          <outline text="#### 1.1.2)javac" _note="编译的Java程序，生成.class文件。&#10;"/>          <outline text="#### 1.1.3)javaw" _note="跟java命令相对的，可以运行.class文件,主要用来执行图形界面的java程序运行java命令时，会出现并保持一个console窗口,程 序中的信息可以通过System.out在console内输出，而运行javaw，开始时会出现console，当主程序调用之后，console就会 消失； javaw 大多用来运行GUI程序。&#10;"/>          <outline text="#### 1.1.4)javah" _note="C 头文件和 Stub 文件生成器。javah 从 Java 类生成 C 头文件和 C 源文件。这些文件提供了连接胶合，使 Java 和 C 代码可进行交互。&#10;"/>          <outline text="#### 1.1.5)javap" _note="用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。&#10;"/>          <outline text="#### 1.1.6)jdb" _note="命令行调试环境，既可在本地，也可在与远程的解释器的一次对话中执行。&#10;"/>          <outline text="#### 1.1.7)javaws" _note="应用程序高速缓存查看器。&#10;"/>          <outline text="#### 1.1.8)jconsole" _note="Java监视和管理控制台,JConsole使用JVM的可扩展性Java管理扩展(JMX)工具来提供关于运行于Java平台的应用程序的性能和资源消耗的信息。&#10;"/>          <outline text="#### 1.1.9)jps" _note="java虚拟机进程状态工具---在目标系统上列出装备有HotSpot Java的虚拟机。&#10;"/>          <outline text="#### 1.1.10)jstat" _note="JVM监控工具,java虚拟机统计监视工具---附加到一个装备了HotSpot的java虚拟机上来采集并且记录性能统计情况。&#10;"/>          <outline text="#### 1.1.11)jstatd" _note="java虚拟机的jstat守护程序---启动一个RMI服务器程序来监视各个HotSpot java虚拟机的创建和中止。并且提供了一个访问远程监视工具接入的接口。&#10;"/>          <outline text="#### 1.1.12)kinit" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.13)klist" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.14)ktab" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.15)native2ascii" _note="将含有本地编码字符（既非 Latin1 又非 Unicode 字符）的文件转换为 Unicode 编码字符的文件。&#10;"/>          <outline text="#### 1.1.16)ordb"/>          <outline text="#### 1.1.17)idlj"/>          <outline text="#### 1.1.18)servertool"/>          <outline text="#### 1.1.19)tnameserv"/>          <outline text="#### 1.1.20)"/>        </outline>        <outline text="### 1.2)javadoc"/>        <outline text="### 1.3)IDE">          <outline text="#### 1.3.1)Eclipse"/>          <outline text="#### 1.3.2)IDEA"/>          <outline text="#### 1.3.3)NetBeans"/>        </outline>        <outline text="### 1.4)版本管理">          <outline text="#### 1.4.1)SVN"/>          <outline text="#### 1.4.2)Git"/>        </outline>      </outline>      <outline text="## 2)基础语法">        <outline text="### 2.1)数据类型">          <outline text="#### 2.1.1)数据类型清单">            <outline text="##### 2.1.1.1)整形/int"/>            <outline text="##### 2.1.1.2)浮点型/float"/>            <outline text="##### 2.1.1.3)字符型/char"/>            <outline text="##### 2.1.1.4)布尔型/boolean"/>          </outline>          <outline text="#### 2.1.2)标识符">            <outline text="##### 2.1.2.1)变量"/>            <outline text="##### 2.1.2.2)常量"/>          </outline>          <outline text="#### 2.1.3)关键字">            <outline text="##### 2.1.3.1)private" _note="&#10;| 关键字          | 同一个包中的其他类 | 不同包中的其他类 | 子类   | 自身   |&#10;| ------------ | --------- | -------- | ---- | ---- |&#10;| private      | No        | No       | No   | Yes  |&#10;| protected    | Yes       | No       | Yes  | Yes  |&#10;| public       | Yes       | Yes      | Yes  | Yes  |&#10;| 无修饰（default） | Yes       | No       | No   | Yes  |&#10;"/>            <outline text="##### 2.1.3.2)public"/>            <outline text="##### 2.1.3.3)protected"/>            <outline text="##### 2.1.3.4)default"/>            <outline text="##### 2.1.3.5)static" _note="&#10;static关键字修饰内容的几个特点：&#10;1. static修饰的变量和类文件一同被加载到内存中&#10;2. 被修饰的方法可以直接通过类名加点来引用，也就是说static修饰部分的引用是不需要将对象实例化的。&#10;    有关static一些**注意事项**：&#10;- static方法只能访问static变量&#10;- static方法中不能使用this,super这样的关键字，因为static优先于对象被加载到内存之中，static执行时对象可能还未被实例化。&#10;- 内部类包含static修饰的属性或方法时，内部类必须也被static修饰，其实理解起来也很简答，应为static会优先被加载，如果内部类不被static修饰，那么内部变量是不会被提前加载的，这时static关键字修饰就不起作用了。&#10;"/>            <outline text="##### 2.1.3.6)final" _note="&#10;- final是一个修饰词，可修饰类，变量，函数&#10;- final修饰的类不可被继承&#10;- final修饰的函数无法被复写&#10;- final修饰的变量只能赋值一次&#10;"/>            <outline text="##### 2.1.3.7)abstract" _note="&#10;- abstract能够修饰方法和类&#10;- abstract修饰的类无法被实例化，只能够通过子类的继承并实现内部所有的抽象函数才能被实例化。&#10;- abstract修饰的函数只需要申明方法名，参数，不需要写函数体。&#10;- 抽象类中同样可以定义非抽象的方法，同时抽象类也有构造函数，这个构造函数提供给子类实例化时使用。&#10;- 抽象类中也可以没有抽象的方法。&#10;- abstract不可以和static，private，final公用，简单理解一下，static修饰说明优先加载，而abstract未被实现，所以无法被优先加载。final修饰表名为最终状态无法修改，而abstract修饰的需要子类去实现，必须可以修改。private表示私有化，自由自身能够访问到，而abstract需要子类访问并实现函数体。&#10;"/>            <outline text="##### 2.1.3.8)instanceof" _note="用于判断类是否实现了指定接口或实现了指定的类，举个简单的例子：&#10;```java&#10;public class Test {&#10;    public static void main(String[] args) {&#10;        NullPointerException e = new NullPointerException();&#10;        System.out.println(e instanceof Exception);&#10;    }&#10;}&#10;//输出结果为true&#10;```&#10;"/>          </outline>          <outline text="#### 2.1.4)类型转换"/>          <outline text="#### 2.1.5)数组"/>          <outline text="#### 2.1.6)枚举"/>        </outline>        <outline text="### 2.2)运算操作">          <outline text="#### 2.2.1)表达式"/>          <outline text="#### 2.2.2)分隔符"/>          <outline text="#### 2.2.3)运算符"/>        </outline>        <outline text="### 2.3)语句控制">          <outline text="#### 2.3.1)循环语句"/>          <outline text="#### 2.3.2)条件语句"/>          <outline text="#### 2.3.3)跳转语句"/>          <outline text="#### 2.3.4)其他语句"/>        </outline>        <outline text="### 2.4)注释"/>        <outline text="### 2.5)修饰符"/>      </outline>      <outline text="## 3)常用基础类库">        <outline text="### 3.1)lang"/>        <outline text="### 3.2)collections"/>        <outline text="### 3.3)io"/>        <outline text="### 3.4)net"/>      </outline>      <outline text="## 4)OOP">        <outline text="### 4.1)OOP思想">          <outline text="#### 4.1.1)封装"/>          <outline text="#### 4.1.2)继承"/>          <outline text="#### 4.1.3)多态"/>        </outline>        <outline text="### 4.2)类与对象">          <outline text="#### 4.2.1)Object类"/>          <outline text="#### 4.2.2)Class类"/>          <outline text="#### 4.2.3)抽象类"/>          <outline text="#### 4.2.4)接口"/>          <outline text="#### 4.2.5)匿名内部类"/>          <outline text="#### 4.2.6)包装类"/>        </outline>        <outline text="### 4.3)类的行为">          <outline text="#### 4.3)构造方法"/>          <outline text="#### 4.3.1)重载(Overload)" _note="&#10;（1） 方法重载是让类以**统一的方式处理不同类型数据**的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。&#10;（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。&#10;（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。&#10;（4） 返回值是方法执行后的结果，我们在调用方法的时候不会指定说“我要调用返回值是xxx类型的方法”，它不成成为方法重载的特征。&#10;（5） 重载的标志：方法名相同，参数不同（个数或者类型），与返回值无关。&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，编译器多态。&#10;**重载的规则：**&#10;1、必须具有不同的参数列表；&#10;2、可以有不责骂的返回类型，只要参数列表不同就可以了；&#10;3、可以有不同的访问修饰符；&#10;4、可以抛出不同的异常；&#10;5、当需要在子类中调用父类的被重写方法时，要使用super关键字。&#10;```java&#10;public class OverloadParent{&#10;  public String getPerson(String name){&#10;    return “personA” + name;&#10;  }&#10;  public String getPerson(int age){&#10;    return “personB” ;&#10;  }&#10;  public String getPerson(String name,int age){&#10;    return “personC”;&#10;  }&#10;  public void getPerson(String name){&#10;    System.out.println(“我是重载的方法吗？”);&#10;  }&#10;}&#10;public class OverloadChildextends OverloadParent {&#10;  public void getPerson(double money){&#10;     Sytem.out.println(“我是重载的方法吗”);&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.2)覆写(Override)" _note="&#10;（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。&#10;但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。&#10;方法覆写又称方法覆盖。&#10;（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。&#10;（3）子类函数的访问修饰权限不能少于父类的；&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，运行期多态。&#10;**覆写方法的规则：**&#10;1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。&#10;2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。&#10;3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）&#10;4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：&#10;父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。&#10;覆写与重载的区别在于：&#10;覆写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。&#10;```java&#10;public class OverrideParent{&#10;   public void fly(){&#10;     System.out.println(“Ican fly!”);&#10;  }&#10;}&#10;public class OverrideChild extends OverrideParent{&#10;  @override&#10;  public void fly(){&#10;       System.out.println(“Ican not fly, but I can run!”);&#10;  }&#10;  public static vid main(String[] args){&#10;       OverwriteParent child= new OverwriteChild();&#10;       child.fly();&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.3)泛型"/>          <outline text="#### 4.3.4)反射"/>        </outline>      </outline>      <outline text="## 5)高级语法">        <outline text="### 5.1)字符串">          <outline text="#### 5.1.1)String"/>          <outline text="#### 5.1.2)StringBuilder"/>          <outline text="#### 5.1.3)StringBuffer"/>        </outline>        <outline text="### 5.2)异常"/>        <outline text="### 5.3)集合">          <outline text="#### 5.3.1)List"/>          <outline text="#### 5.3.2)Set"/>          <outline text="#### 5.3.3)Map"/>          <outline text="#### 5.3.4)数组"/>        </outline>        <outline text="### 5.4)可变参数"/>        <outline text="### 5.5)静态导入"/>        <outline text="### 5.6)Annotation"/>        <outline text="### 5.7)Lambda"/>        <outline text="### 5.8)正则表达式">          <outline text="#### 5.8.1)Regex"/>        </outline>        <outline text="### 5.9)JDBC">          <outline text="#### 5.9.1.)JDBC基础"/>          <outline text="#### 5.9.2)连接池技术"/>          <outline text="#### 5.9.3)jdbc的dao封装"/>        </outline>        <outline text="### 5.10)JVM">          <outline text="#### 5.10.1)内存"/>          <outline text="#### 5.10.2)GC"/>        </outline>        <outline text="### 5.11)多线程">          <outline text="#### 5.11.1)线程池"/>          <outline text="#### 5.11.2)线程安全集合"/>          <outline text="#### 5.11.3)线程锁"/>        </outline>        <outline text="### 5.12)国际化">          <outline text="#### 5.12.1)字符集"/>        </outline>        <outline text="### 5.13)比较器"/>        <outline text="### 5.14)文件与流">          <outline text="#### 5.14.1)文件操作类"/>          <outline text="#### 5.14.2)字节流与字符流">            <outline text="##### 5.14.2.1)文件的读入"/>            <outline text="##### 5.14.2.1.1)按字节读取文件内容" _note="```java&#10;public static void readFileByBytes(String fileName) {&#10;    File file = new File(fileName);&#10;    InputStream in = null;&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);&#10;        // 一次读一个字节&#10;        in = new FileInputStream(file);&#10;        int tempbyte;&#10;        while ((tempbyte = in.read()) != -1) {&#10;            System.out.write(tempbyte);&#10;        }&#10;        in.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;        return;&#10;    }&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读多个字节：&quot;);&#10;        // 一次读多个字节&#10;        byte[] tempbytes = new byte[100];&#10;        int byteread = 0;&#10;        in = new FileInputStream(fileName);&#10;        ReadFromFile.showAvailableBytes(in);&#10;        // 读入多个字节到字节数组中，byteread为一次读入的字节数&#10;        while ((byteread = in.read(tempbytes)) != -1) {&#10;            System.out.write(tempbytes, 0, byteread);&#10;        }&#10;    } catch (Exception e1) {&#10;        e1.printStackTrace();&#10;    } finally {&#10;        if (in != null) {&#10;            try {&#10;                in.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;private static void showAvailableBytes(InputStream in) {&#10;    try {&#10;        System.out.println(&quot;当前字节输入流中的字节数为:&quot; + in.available());&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.2)按字符读取文件内容" _note="```java&#10;public static void readFileByChars(String fileName) {&#10;     File file = new File(fileName);&#10;     Reader reader = null;&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读一个字节：&quot;);&#10;         // 一次读一个字符&#10;         reader = new InputStreamReader(new FileInputStream(file));&#10;         int tempchar;&#10;         while ((tempchar = reader.read()) != -1) {&#10;             // 对于windows下，\r\n这两个字符在一起时，表示一个换行。&#10;             // 但如果这两个字符分开显示时，会换两次行。&#10;             // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。&#10;             if (((char) tempchar) != '\r') {&#10;                 System.out.print((char) tempchar);&#10;             }&#10;         }&#10;         reader.close();&#10;     } catch (Exception e) {&#10;         e.printStackTrace();&#10;     }&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读多个字节：&quot;);&#10;         // 一次读多个字符&#10;         char[] tempchars = new char[30];&#10;         int charread = 0;&#10;         reader = new InputStreamReader(new FileInputStream(fileName));&#10;         // 读入多个字符到字符数组中，charread为一次读取字符数&#10;         while ((charread = reader.read(tempchars)) != -1) {&#10;             // 同样屏蔽掉\r不显示&#10;             if ((charread == tempchars.length) &amp;&amp; (tempchars[tempchars.length - 1] != '\r')) {&#10;                  System.out.print(tempchars);&#10;             } else {&#10;                 for (int i = 0; i &lt; charread; i++) {&#10;                     if (tempchars[i] == '\r') {&#10;                         continue;&#10;                     } else {&#10;                         System.out.print(tempchars[i]);&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (Exception e1) {&#10;         e1.printStackTrace();&#10;     } finally {&#10;         if (reader != null) {&#10;             try {&#10;                 reader.close();&#10;             } catch (IOException e1) {&#10;             }&#10;         }&#10;     }&#10; }&#10;```&#10;"/>            <outline text="##### 5.14.2.1.3)按行读取文件内容" _note="```java&#10;public static void readFileByLines(String fileName) {&#10;    File file = new File(fileName);&#10;    BufferedReader reader = null;&#10;    try {&#10;        System.out.println(&quot;以行为单位读取文件内容，一次读一整行：&quot;);&#10;        reader = new BufferedReader(new FileReader(file));&#10;        String tempString = null;&#10;        int line = 1;&#10;        // 一次读入一行，直到读入null为文件结束&#10;        while ((tempString = reader.readLine()) != null) {&#10;            // 显示行号&#10;            System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);&#10;            line++;&#10;        }&#10;        reader.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (reader != null) {&#10;            try {&#10;                reader.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.4)随机读取文件内容" _note="```java&#10;public static void readFileByRandomAccess(String fileName) {&#10;    RandomAccessFile randomFile = null;&#10;    try {&#10;        System.out.println(&quot;随机读取一段文件内容：&quot;);&#10;        // 打开一个随机访问文件流，按只读方式&#10;        randomFile = new RandomAccessFile(fileName, &quot;r&quot;);&#10;        // 文件长度，字节数&#10;        long fileLength = randomFile.length();&#10;        // 读文件的起始位置&#10;        int beginIndex = (fileLength &gt; 4) ? 4 : 0;&#10;        // 将读文件的开始位置移到beginIndex位置。&#10;        randomFile.seek(beginIndex);&#10;        byte[] bytes = new byte[10];&#10;        int byteread = 0;&#10;        // 一次读10个字节，如果文件内容不足10个字节，则读剩下的字节。&#10;        // 将一次读取的字节数赋给byteread&#10;        while ((byteread = randomFile.read(bytes)) != -1) {&#10;            System.out.write(bytes, 0, byteread);&#10;        }&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (randomFile != null) {&#10;            try {&#10;                randomFile.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.2)文件的写入"/>            <outline text="##### 5.14.2.2.1)FileWritter写入文件" _note="```java&#10;public static void main( String[] args ){&#10;　　   try{&#10;　　         String data = &quot; This content will append to the end of the file&quot;;&#10;　　         File file =new File(&quot;javaio-appendfile.txt&quot;);&#10;　　         //if file doesnt exists, then create it&#10;　　         if(!file.exists()){&#10;　　              file.createNewFile();&#10;　　          }&#10;　　         //true = append file&#10;　　         FileWriter fileWritter = new FileWriter(file.getName(),true);&#10;　　         BufferedWriter bufferWritter = new BufferedWriter(fileWritter);&#10;　　         bufferWritter.write(data);&#10;　　         bufferWritter.close();&#10;　　         System.out.println(&quot;Done&quot;);&#10;　　   }catch(IOException e){&#10;　　        e.printStackTrace();&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.2)BufferedWriter写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    try {&#10;　　        String content = &quot;This is the content to write into file&quot;;&#10;　　        File file = new File(&quot;/users/mkyong/filename.txt&quot;);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　           file.createNewFile();&#10;　　       }&#10;　　       FileWriter fw = new FileWriter(file.getAbsoluteFile());&#10;　　       BufferedWriter bw = new BufferedWriter(fw);&#10;　　       bw.write(content);&#10;　　       bw.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　    } catch (IOException e) {&#10;　　         e.printStackTrace();&#10;　　    }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.3)FileOutputStream写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    FileOutputStream fop = null;&#10;　　    File file;&#10;　　    String content = &quot;This is the text content&quot;;&#10;　　    try {&#10;　　        file = new File(&quot;c:/newfile.txt&quot;);&#10;　　        fop = new FileOutputStream(file);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　            file.createNewFile();&#10;　　       }&#10;　　       // get the content in bytes&#10;　　       byte[] contentInBytes = content.getBytes();&#10;　　       fop.write(contentInBytes);&#10;　　       fop.flush();&#10;　　       fop.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　   } catch (IOException e) {&#10;　　       e.printStackTrace();&#10;　　   } finally {&#10;　　       try {&#10;　　           if (fop != null) {&#10;　　               fop.close();&#10;　　           }&#10;　　       } catch (IOException e) {&#10;　　             e.printStackTrace();&#10;　　       }&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.4)几种方法的比较" _note="相对而言，FileWritter最快，FileOutputStream最慢&#10;"/>          </outline>        </outline>        <outline text="### 5.15)序列化"/>      </outline>      <outline text="## 6)开源专题">        <outline text="### 6.1)Log">          <outline text="#### 6.1.1)Log4j"/>          <outline text="#### 6.1.2)SLF4J"/>        </outline>        <outline text="### 6.2)ORM">          <outline text="#### 6.2.1)Hibernate"/>          <outline text="#### 6.2.2)MyBatis">            <outline text="##### 6.2.2.1)1.mybatis简介"/>            <outline text="##### 6.2.2.2)2.基本增删改查"/>            <outline text="##### 6.2.2.3)3.注解方式实现"/>            <outline text="##### 6.2.2.4)4.动态SQL"/>            <outline text="##### 6.2.2.5)5.多种参数传递"/>            <outline text="##### 6.2.2.6)6.一对一"/>            <outline text="##### 6.2.2).77.一对多"/>            <outline text="##### 6.2.2.8)8.多对多"/>          </outline>        </outline>        <outline text="### 6.3)Test">          <outline text="#### 6.3.1)JUnit"/>        </outline>        <outline text="### 6.4)Build">          <outline text="#### 6.4.1)Ant"/>          <outline text="#### 6.4.2)Maven"/>          <outline text="#### 6.4.3)Gradle"/>        </outline>        <outline text="### 6.5)脚本语言">          <outline text="#### 6.5.1)Groovy"/>          <outline text="#### 6.5.2)velocity"/>        </outline>        <outline text="### 6.6)Spring">          <outline text="#### 6.6.1)SpringCore">            <outline text="##### 6.6.1.2)01.了解Spring"/>            <outline text="##### 6.6.1.2)02.IOC思想"/>            <outline text="##### 6.6.1.3)03.DI依赖注入"/>            <outline text="##### 6.6.1.4)04.控制反转"/>            <outline text="##### 6.6.1.5)05.代理"/>            <outline text="##### 6.6.1.6)06.事务管理"/>            <outline text="##### 6.6.1.7)07.Bean生命周期"/>            <outline text="##### 6.6.1.8)08.集合注入"/>            <outline text="##### 6.6.1.9)09.AOP概念"/>            <outline text="##### 6.6.1.10)10.Spring注解"/>          </outline>          <outline text="#### 6.6.2)SpringMVC">            <outline text="##### 6.6.2.1)SpringMVC简介"/>            <outline text="##### 6.6.2.2)handleMapping"/>            <outline text="##### 6.6.2.3)RequestMapping"/>            <outline text="##### 6.6.2.4)SpringMVC参数传递"/>            <outline text="##### 6.6.2.5)返回页面数据"/>            <outline text="##### 6.6.2.6)适配器"/>            <outline text="##### 6.6.2.7)拦截器"/>            <outline text="##### 6.6.2.8)视图与模型"/>            <outline text="##### 6.6.2.9)上传文件"/>            <outline text="##### 6.6.2.10)AJAX的使用"/>            <outline text="##### 6.6.2.11)SpringMVC与Struts区别"/>          </outline>          <outline text="#### 6.6.3)SpringBoost"/>        </outline>        <outline text="### 6.7)前端技术"/>        <outline text="### 6.8)XML">          <outline text="#### 6.8.1)Dom4j"/>        </outline>        <outline text="### 6.9)配置文件"/>      </outline>      <outline text="## 7)算法与设计模式">        <outline text="### 7.1)设计模式">          <outline text="#### 7.1.1)GOF">            <outline text="##### 7.1.1.1)创建型">              <outline text="###### 7.1.1.1.1)Factory Method（工厂方法）"/>              <outline text="###### 7.1.1.1.2)Abstract Factory（抽象工厂）"/>              <outline text="###### 7.1.1.1.3)Builder（建造者）"/>              <outline text="###### 7.1.1.1.4)Prototype（原型）"/>              <outline text="###### 7.1.1.1.5)Singleton（单例）"/>            </outline>            <outline text="##### 7.1.1.2)结构型">              <outline text="###### 7.1.1.2.1)Adapter Class/Object（适配器）"/>              <outline text="###### 7.1.1.2.2)Bridge（桥接）"/>              <outline text="###### 7.1.1.2.3)Composite（组合）"/>              <outline text="###### 7.1.1.2.4)Decorator（装饰）"/>              <outline text="###### 7.1.1.2.5)Facade（外观）"/>              <outline text="###### 7.1.1.2.6)Flyweight（享元）"/>              <outline text="###### 7.1.1.2.7)Proxy（代理）"/>            </outline>            <outline text="##### 7.1.1.3)行为型">              <outline text="###### 7.1.1.3.1)Interpreter（解释器）"/>              <outline text="###### 7.1.1.3.2)Template Method（模板方法）"/>              <outline text="###### 7.1.1.3.3)Chain of Responsibility（责任链）"/>              <outline text="###### 7.1.1.3.4)Command（命令）"/>              <outline text="###### 7.1.1.3.5)Iterator（迭代器）"/>              <outline text="###### 7.1.1.3.6)Mediator（中介者）"/>              <outline text="###### 7.1.1.3.7)Memento（备忘录）"/>              <outline text="###### 7.1.1.3.8)Observer（观察者）"/>              <outline text="###### 7.1.1.3.9)State（状态）"/>              <outline text="###### 7.1.1.3.10)Strategy（策略）"/>              <outline text="###### 7.1.1.3.11)Visitor（访问者）"/>            </outline>          </outline>          <outline text="#### 7.1.2)六大原则">            <outline text="##### 7.1.2.1)1、开闭原则（Open Close Principle）"/>            <outline text="##### 7.1.2.2)2、里氏代换原则（Liskov Substitution Principle）"/>            <outline text="##### 7.1.2.3)3、依赖倒转原则（Dependence Inversion Principle）"/>            <outline text="##### 7.1.2.4)4、接口隔离原则（Interface Segregation Principle）"/>            <outline text="##### 7.1.2.5)5、迪米特法则（最少知道原则）（Demeter Principle）"/>            <outline text="##### 7.1.2.6)6、合成复用原则（Composite Reuse Principle）"/>          </outline>        </outline>        <outline text="### 7.2)算法">          <outline text="#### 7.2.1)算法（第四版）"/>        </outline>      </outline>      <outline text="## 8)项目"/>      <outline text="## 9)试题"/>      <outline text="## 0)文化"/>    </outline>  </body></opml><?xml version="1.0" encoding="UTF-8"?><opml>  <head>    <title></title>    <dateModified></dateModified>    <ownerName></ownerName>  </head>  <body>    <outline text="# Java" 栏2="第一行&#10;第二行&#10;第四行&#10;">      <outline text="#### 我就是四级菜单"/>      <outline text="## 1)环境">        <outline text="### Java简介"/>        <outline text="### JDK的安装与配置"/>        <outline text="### 1.1)命令" _note="参考文档：https://blog.csdn.net/yang889999888/article/details/72823261&#10;">          <outline text="#### 1.1.1)java" _note="运行java程序。&#10;"/>          <outline text="#### 1.1.2)javac" _note="编译的Java程序，生成.class文件。&#10;"/>          <outline text="#### 1.1.3)javaw" _note="跟java命令相对的，可以运行.class文件,主要用来执行图形界面的java程序运行java命令时，会出现并保持一个console窗口,程 序中的信息可以通过System.out在console内输出，而运行javaw，开始时会出现console，当主程序调用之后，console就会 消失； javaw 大多用来运行GUI程序。&#10;"/>          <outline text="#### 1.1.4)javah" _note="C 头文件和 Stub 文件生成器。javah 从 Java 类生成 C 头文件和 C 源文件。这些文件提供了连接胶合，使 Java 和 C 代码可进行交互。&#10;"/>          <outline text="#### 1.1.5)javap" _note="用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。&#10;"/>          <outline text="#### 1.1.6)jdb" _note="命令行调试环境，既可在本地，也可在与远程的解释器的一次对话中执行。&#10;"/>          <outline text="#### 1.1.7)javaws" _note="应用程序高速缓存查看器。&#10;"/>          <outline text="#### 1.1.8)jconsole" _note="Java监视和管理控制台,JConsole使用JVM的可扩展性Java管理扩展(JMX)工具来提供关于运行于Java平台的应用程序的性能和资源消耗的信息。&#10;"/>          <outline text="#### 1.1.9)jps" _note="java虚拟机进程状态工具---在目标系统上列出装备有HotSpot Java的虚拟机。&#10;"/>          <outline text="#### 1.1.10)jstat" _note="JVM监控工具,java虚拟机统计监视工具---附加到一个装备了HotSpot的java虚拟机上来采集并且记录性能统计情况。&#10;"/>          <outline text="#### 1.1.11)jstatd" _note="java虚拟机的jstat守护程序---启动一个RMI服务器程序来监视各个HotSpot java虚拟机的创建和中止。并且提供了一个访问远程监视工具接入的接口。&#10;"/>          <outline text="#### 1.1.12)kinit" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.13)klist" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.14)ktab" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.15)native2ascii" _note="将含有本地编码字符（既非 Latin1 又非 Unicode 字符）的文件转换为 Unicode 编码字符的文件。&#10;"/>          <outline text="#### 1.1.16)ordb"/>          <outline text="#### 1.1.17)idlj"/>          <outline text="#### 1.1.18)servertool"/>          <outline text="#### 1.1.19)tnameserv"/>          <outline text="#### 1.1.20)"/>        </outline>        <outline text="### 1.2)javadoc"/>        <outline text="### 1.3)IDE">          <outline text="#### 1.3.1)Eclipse"/>          <outline text="#### 1.3.2)IDEA"/>          <outline text="#### 1.3.3)NetBeans"/>        </outline>        <outline text="### 1.4)版本管理">          <outline text="#### 1.4.1)SVN"/>          <outline text="#### 1.4.2)Git"/>        </outline>      </outline>      <outline text="## 2)基础语法">        <outline text="### 2.1)数据类型">          <outline text="#### 2.1.1)数据类型清单">            <outline text="##### 2.1.1.1)整形/int"/>            <outline text="##### 2.1.1.2)浮点型/float"/>            <outline text="##### 2.1.1.3)字符型/char"/>            <outline text="##### 2.1.1.4)布尔型/boolean"/>          </outline>          <outline text="#### 2.1.2)标识符">            <outline text="##### 2.1.2.1)变量"/>            <outline text="##### 2.1.2.2)常量"/>          </outline>          <outline text="#### 2.1.3)关键字">            <outline text="##### 2.1.3.1)private" _note="&#10;| 关键字          | 同一个包中的其他类 | 不同包中的其他类 | 子类   | 自身   |&#10;| ------------ | --------- | -------- | ---- | ---- |&#10;| private      | No        | No       | No   | Yes  |&#10;| protected    | Yes       | No       | Yes  | Yes  |&#10;| public       | Yes       | Yes      | Yes  | Yes  |&#10;| 无修饰（default） | Yes       | No       | No   | Yes  |&#10;"/>            <outline text="##### 2.1.3.2)public"/>            <outline text="##### 2.1.3.3)protected"/>            <outline text="##### 2.1.3.4)default"/>            <outline text="##### 2.1.3.5)static" _note="&#10;static关键字修饰内容的几个特点：&#10;1. static修饰的变量和类文件一同被加载到内存中&#10;2. 被修饰的方法可以直接通过类名加点来引用，也就是说static修饰部分的引用是不需要将对象实例化的。&#10;    有关static一些**注意事项**：&#10;- static方法只能访问static变量&#10;- static方法中不能使用this,super这样的关键字，因为static优先于对象被加载到内存之中，static执行时对象可能还未被实例化。&#10;- 内部类包含static修饰的属性或方法时，内部类必须也被static修饰，其实理解起来也很简答，应为static会优先被加载，如果内部类不被static修饰，那么内部变量是不会被提前加载的，这时static关键字修饰就不起作用了。&#10;"/>            <outline text="##### 2.1.3.6)final" _note="&#10;- final是一个修饰词，可修饰类，变量，函数&#10;- final修饰的类不可被继承&#10;- final修饰的函数无法被复写&#10;- final修饰的变量只能赋值一次&#10;"/>            <outline text="##### 2.1.3.7)abstract" _note="&#10;- abstract能够修饰方法和类&#10;- abstract修饰的类无法被实例化，只能够通过子类的继承并实现内部所有的抽象函数才能被实例化。&#10;- abstract修饰的函数只需要申明方法名，参数，不需要写函数体。&#10;- 抽象类中同样可以定义非抽象的方法，同时抽象类也有构造函数，这个构造函数提供给子类实例化时使用。&#10;- 抽象类中也可以没有抽象的方法。&#10;- abstract不可以和static，private，final公用，简单理解一下，static修饰说明优先加载，而abstract未被实现，所以无法被优先加载。final修饰表名为最终状态无法修改，而abstract修饰的需要子类去实现，必须可以修改。private表示私有化，自由自身能够访问到，而abstract需要子类访问并实现函数体。&#10;"/>            <outline text="##### 2.1.3.8)instanceof" _note="用于判断类是否实现了指定接口或实现了指定的类，举个简单的例子：&#10;```java&#10;public class Test {&#10;    public static void main(String[] args) {&#10;        NullPointerException e = new NullPointerException();&#10;        System.out.println(e instanceof Exception);&#10;    }&#10;}&#10;//输出结果为true&#10;```&#10;"/>          </outline>          <outline text="#### 2.1.4)类型转换"/>          <outline text="#### 2.1.5)数组"/>          <outline text="#### 2.1.6)枚举"/>        </outline>        <outline text="### 2.2)运算操作">          <outline text="#### 2.2.1)表达式"/>          <outline text="#### 2.2.2)分隔符"/>          <outline text="#### 2.2.3)运算符"/>        </outline>        <outline text="### 2.3)语句控制">          <outline text="#### 2.3.1)循环语句"/>          <outline text="#### 2.3.2)条件语句"/>          <outline text="#### 2.3.3)跳转语句"/>          <outline text="#### 2.3.4)其他语句"/>        </outline>        <outline text="### 2.4)注释"/>        <outline text="### 2.5)修饰符"/>      </outline>      <outline text="## 3)常用基础类库">        <outline text="### 3.1)lang"/>        <outline text="### 3.2)collections"/>        <outline text="### 3.3)io"/>        <outline text="### 3.4)net"/>      </outline>      <outline text="## 4)OOP">        <outline text="### 4.1)OOP思想">          <outline text="#### 4.1.1)封装"/>          <outline text="#### 4.1.2)继承"/>          <outline text="#### 4.1.3)多态"/>        </outline>        <outline text="### 4.2)类与对象">          <outline text="#### 4.2.1)Object类"/>          <outline text="#### 4.2.2)Class类"/>          <outline text="#### 4.2.3)抽象类"/>          <outline text="#### 4.2.4)接口"/>          <outline text="#### 4.2.5)匿名内部类"/>          <outline text="#### 4.2.6)包装类"/>        </outline>        <outline text="### 4.3)类的行为">          <outline text="#### 4.3)构造方法"/>          <outline text="#### 4.3.1)重载(Overload)" _note="&#10;（1） 方法重载是让类以**统一的方式处理不同类型数据**的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。&#10;（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。&#10;（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。&#10;（4） 返回值是方法执行后的结果，我们在调用方法的时候不会指定说“我要调用返回值是xxx类型的方法”，它不成成为方法重载的特征。&#10;（5） 重载的标志：方法名相同，参数不同（个数或者类型），与返回值无关。&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，编译器多态。&#10;**重载的规则：**&#10;1、必须具有不同的参数列表；&#10;2、可以有不责骂的返回类型，只要参数列表不同就可以了；&#10;3、可以有不同的访问修饰符；&#10;4、可以抛出不同的异常；&#10;5、当需要在子类中调用父类的被重写方法时，要使用super关键字。&#10;```java&#10;public class OverloadParent{&#10;  public String getPerson(String name){&#10;    return “personA” + name;&#10;  }&#10;  public String getPerson(int age){&#10;    return “personB” ;&#10;  }&#10;  public String getPerson(String name,int age){&#10;    return “personC”;&#10;  }&#10;  public void getPerson(String name){&#10;    System.out.println(“我是重载的方法吗？”);&#10;  }&#10;}&#10;public class OverloadChildextends OverloadParent {&#10;  public void getPerson(double money){&#10;     Sytem.out.println(“我是重载的方法吗”);&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.2)覆写(Override)" _note="&#10;（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。&#10;但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。&#10;方法覆写又称方法覆盖。&#10;（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。&#10;（3）子类函数的访问修饰权限不能少于父类的；&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，运行期多态。&#10;**覆写方法的规则：**&#10;1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。&#10;2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。&#10;3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）&#10;4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：&#10;父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。&#10;覆写与重载的区别在于：&#10;覆写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。&#10;```java&#10;public class OverrideParent{&#10;   public void fly(){&#10;     System.out.println(“Ican fly!”);&#10;  }&#10;}&#10;public class OverrideChild extends OverrideParent{&#10;  @override&#10;  public void fly(){&#10;       System.out.println(“Ican not fly, but I can run!”);&#10;  }&#10;  public static vid main(String[] args){&#10;       OverwriteParent child= new OverwriteChild();&#10;       child.fly();&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.3)泛型"/>          <outline text="#### 4.3.4)反射"/>        </outline>      </outline>      <outline text="## 5)高级语法">        <outline text="### 5.1)字符串">          <outline text="#### 5.1.1)String"/>          <outline text="#### 5.1.2)StringBuilder"/>          <outline text="#### 5.1.3)StringBuffer"/>        </outline>        <outline text="### 5.2)异常"/>        <outline text="### 5.3)集合">          <outline text="#### 5.3.1)List"/>          <outline text="#### 5.3.2)Set"/>          <outline text="#### 5.3.3)Map"/>          <outline text="#### 5.3.4)数组"/>        </outline>        <outline text="### 5.4)可变参数"/>        <outline text="### 5.5)静态导入"/>        <outline text="### 5.6)Annotation"/>        <outline text="### 5.7)Lambda"/>        <outline text="### 5.8)正则表达式">          <outline text="#### 5.8.1)Regex"/>        </outline>        <outline text="### 5.9)JDBC">          <outline text="#### 5.9.1.)JDBC基础"/>          <outline text="#### 5.9.2)连接池技术"/>          <outline text="#### 5.9.3)jdbc的dao封装"/>        </outline>        <outline text="### 5.10)JVM">          <outline text="#### 5.10.1)内存"/>          <outline text="#### 5.10.2)GC"/>        </outline>        <outline text="### 5.11)多线程">          <outline text="#### 5.11.1)线程池"/>          <outline text="#### 5.11.2)线程安全集合"/>          <outline text="#### 5.11.3)线程锁"/>        </outline>        <outline text="### 5.12)国际化">          <outline text="#### 5.12.1)字符集"/>        </outline>        <outline text="### 5.13)比较器"/>        <outline text="### 5.14)文件与流">          <outline text="#### 5.14.1)文件操作类"/>          <outline text="#### 5.14.2)字节流与字符流">            <outline text="##### 5.14.2.1)文件的读入"/>            <outline text="##### 5.14.2.1.1)按字节读取文件内容" _note="```java&#10;public static void readFileByBytes(String fileName) {&#10;    File file = new File(fileName);&#10;    InputStream in = null;&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);&#10;        // 一次读一个字节&#10;        in = new FileInputStream(file);&#10;        int tempbyte;&#10;        while ((tempbyte = in.read()) != -1) {&#10;            System.out.write(tempbyte);&#10;        }&#10;        in.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;        return;&#10;    }&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读多个字节：&quot;);&#10;        // 一次读多个字节&#10;        byte[] tempbytes = new byte[100];&#10;        int byteread = 0;&#10;        in = new FileInputStream(fileName);&#10;        ReadFromFile.showAvailableBytes(in);&#10;        // 读入多个字节到字节数组中，byteread为一次读入的字节数&#10;        while ((byteread = in.read(tempbytes)) != -1) {&#10;            System.out.write(tempbytes, 0, byteread);&#10;        }&#10;    } catch (Exception e1) {&#10;        e1.printStackTrace();&#10;    } finally {&#10;        if (in != null) {&#10;            try {&#10;                in.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;private static void showAvailableBytes(InputStream in) {&#10;    try {&#10;        System.out.println(&quot;当前字节输入流中的字节数为:&quot; + in.available());&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.2)按字符读取文件内容" _note="```java&#10;public static void readFileByChars(String fileName) {&#10;     File file = new File(fileName);&#10;     Reader reader = null;&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读一个字节：&quot;);&#10;         // 一次读一个字符&#10;         reader = new InputStreamReader(new FileInputStream(file));&#10;         int tempchar;&#10;         while ((tempchar = reader.read()) != -1) {&#10;             // 对于windows下，\r\n这两个字符在一起时，表示一个换行。&#10;             // 但如果这两个字符分开显示时，会换两次行。&#10;             // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。&#10;             if (((char) tempchar) != '\r') {&#10;                 System.out.print((char) tempchar);&#10;             }&#10;         }&#10;         reader.close();&#10;     } catch (Exception e) {&#10;         e.printStackTrace();&#10;     }&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读多个字节：&quot;);&#10;         // 一次读多个字符&#10;         char[] tempchars = new char[30];&#10;         int charread = 0;&#10;         reader = new InputStreamReader(new FileInputStream(fileName));&#10;         // 读入多个字符到字符数组中，charread为一次读取字符数&#10;         while ((charread = reader.read(tempchars)) != -1) {&#10;             // 同样屏蔽掉\r不显示&#10;             if ((charread == tempchars.length) &amp;&amp; (tempchars[tempchars.length - 1] != '\r')) {&#10;                  System.out.print(tempchars);&#10;             } else {&#10;                 for (int i = 0; i &lt; charread; i++) {&#10;                     if (tempchars[i] == '\r') {&#10;                         continue;&#10;                     } else {&#10;                         System.out.print(tempchars[i]);&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (Exception e1) {&#10;         e1.printStackTrace();&#10;     } finally {&#10;         if (reader != null) {&#10;             try {&#10;                 reader.close();&#10;             } catch (IOException e1) {&#10;             }&#10;         }&#10;     }&#10; }&#10;```&#10;"/>            <outline text="##### 5.14.2.1.3)按行读取文件内容" _note="```java&#10;public static void readFileByLines(String fileName) {&#10;    File file = new File(fileName);&#10;    BufferedReader reader = null;&#10;    try {&#10;        System.out.println(&quot;以行为单位读取文件内容，一次读一整行：&quot;);&#10;        reader = new BufferedReader(new FileReader(file));&#10;        String tempString = null;&#10;        int line = 1;&#10;        // 一次读入一行，直到读入null为文件结束&#10;        while ((tempString = reader.readLine()) != null) {&#10;            // 显示行号&#10;            System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);&#10;            line++;&#10;        }&#10;        reader.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (reader != null) {&#10;            try {&#10;                reader.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.4)随机读取文件内容" _note="```java&#10;public static void readFileByRandomAccess(String fileName) {&#10;    RandomAccessFile randomFile = null;&#10;    try {&#10;        System.out.println(&quot;随机读取一段文件内容：&quot;);&#10;        // 打开一个随机访问文件流，按只读方式&#10;        randomFile = new RandomAccessFile(fileName, &quot;r&quot;);&#10;        // 文件长度，字节数&#10;        long fileLength = randomFile.length();&#10;        // 读文件的起始位置&#10;        int beginIndex = (fileLength &gt; 4) ? 4 : 0;&#10;        // 将读文件的开始位置移到beginIndex位置。&#10;        randomFile.seek(beginIndex);&#10;        byte[] bytes = new byte[10];&#10;        int byteread = 0;&#10;        // 一次读10个字节，如果文件内容不足10个字节，则读剩下的字节。&#10;        // 将一次读取的字节数赋给byteread&#10;        while ((byteread = randomFile.read(bytes)) != -1) {&#10;            System.out.write(bytes, 0, byteread);&#10;        }&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (randomFile != null) {&#10;            try {&#10;                randomFile.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.2)文件的写入"/>            <outline text="##### 5.14.2.2.1)FileWritter写入文件" _note="```java&#10;public static void main( String[] args ){&#10;　　   try{&#10;　　         String data = &quot; This content will append to the end of the file&quot;;&#10;　　         File file =new File(&quot;javaio-appendfile.txt&quot;);&#10;　　         //if file doesnt exists, then create it&#10;　　         if(!file.exists()){&#10;　　              file.createNewFile();&#10;　　          }&#10;　　         //true = append file&#10;　　         FileWriter fileWritter = new FileWriter(file.getName(),true);&#10;　　         BufferedWriter bufferWritter = new BufferedWriter(fileWritter);&#10;　　         bufferWritter.write(data);&#10;　　         bufferWritter.close();&#10;　　         System.out.println(&quot;Done&quot;);&#10;　　   }catch(IOException e){&#10;　　        e.printStackTrace();&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.2)BufferedWriter写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    try {&#10;　　        String content = &quot;This is the content to write into file&quot;;&#10;　　        File file = new File(&quot;/users/mkyong/filename.txt&quot;);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　           file.createNewFile();&#10;　　       }&#10;　　       FileWriter fw = new FileWriter(file.getAbsoluteFile());&#10;　　       BufferedWriter bw = new BufferedWriter(fw);&#10;　　       bw.write(content);&#10;　　       bw.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　    } catch (IOException e) {&#10;　　         e.printStackTrace();&#10;　　    }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.3)FileOutputStream写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    FileOutputStream fop = null;&#10;　　    File file;&#10;　　    String content = &quot;This is the text content&quot;;&#10;　　    try {&#10;　　        file = new File(&quot;c:/newfile.txt&quot;);&#10;　　        fop = new FileOutputStream(file);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　            file.createNewFile();&#10;　　       }&#10;　　       // get the content in bytes&#10;　　       byte[] contentInBytes = content.getBytes();&#10;　　       fop.write(contentInBytes);&#10;　　       fop.flush();&#10;　　       fop.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　   } catch (IOException e) {&#10;　　       e.printStackTrace();&#10;　　   } finally {&#10;　　       try {&#10;　　           if (fop != null) {&#10;　　               fop.close();&#10;　　           }&#10;　　       } catch (IOException e) {&#10;　　             e.printStackTrace();&#10;　　       }&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.4)几种方法的比较" _note="相对而言，FileWritter最快，FileOutputStream最慢&#10;"/>          </outline>        </outline>        <outline text="### 5.15)序列化"/>      </outline>      <outline text="## 6)开源专题">        <outline text="### 6.1)Log">          <outline text="#### 6.1.1)Log4j"/>          <outline text="#### 6.1.2)SLF4J"/>        </outline>        <outline text="### 6.2)ORM">          <outline text="#### 6.2.1)Hibernate"/>          <outline text="#### 6.2.2)MyBatis">            <outline text="##### 6.2.2.1)1.mybatis简介"/>            <outline text="##### 6.2.2.2)2.基本增删改查"/>            <outline text="##### 6.2.2.3)3.注解方式实现"/>            <outline text="##### 6.2.2.4)4.动态SQL"/>            <outline text="##### 6.2.2.5)5.多种参数传递"/>            <outline text="##### 6.2.2.6)6.一对一"/>            <outline text="##### 6.2.2).77.一对多"/>            <outline text="##### 6.2.2.8)8.多对多"/>          </outline>        </outline>        <outline text="### 6.3)Test">          <outline text="#### 6.3.1)JUnit"/>        </outline>        <outline text="### 6.4)Build">          <outline text="#### 6.4.1)Ant"/>          <outline text="#### 6.4.2)Maven"/>          <outline text="#### 6.4.3)Gradle"/>        </outline>        <outline text="### 6.5)脚本语言">          <outline text="#### 6.5.1)Groovy"/>          <outline text="#### 6.5.2)velocity"/>        </outline>        <outline text="### 6.6)Spring">          <outline text="#### 6.6.1)SpringCore">            <outline text="##### 6.6.1.2)01.了解Spring"/>            <outline text="##### 6.6.1.2)02.IOC思想"/>            <outline text="##### 6.6.1.3)03.DI依赖注入"/>            <outline text="##### 6.6.1.4)04.控制反转"/>            <outline text="##### 6.6.1.5)05.代理"/>            <outline text="##### 6.6.1.6)06.事务管理"/>            <outline text="##### 6.6.1.7)07.Bean生命周期"/>            <outline text="##### 6.6.1.8)08.集合注入"/>            <outline text="##### 6.6.1.9)09.AOP概念"/>            <outline text="##### 6.6.1.10)10.Spring注解"/>          </outline>          <outline text="#### 6.6.2)SpringMVC">            <outline text="##### 6.6.2.1)SpringMVC简介"/>            <outline text="##### 6.6.2.2)handleMapping"/>            <outline text="##### 6.6.2.3)RequestMapping"/>            <outline text="##### 6.6.2.4)SpringMVC参数传递"/>            <outline text="##### 6.6.2.5)返回页面数据"/>            <outline text="##### 6.6.2.6)适配器"/>            <outline text="##### 6.6.2.7)拦截器"/>            <outline text="##### 6.6.2.8)视图与模型"/>            <outline text="##### 6.6.2.9)上传文件"/>            <outline text="##### 6.6.2.10)AJAX的使用"/>            <outline text="##### 6.6.2.11)SpringMVC与Struts区别"/>          </outline>          <outline text="#### 6.6.3)SpringBoost"/>        </outline>        <outline text="### 6.7)前端技术"/>        <outline text="### 6.8)XML">          <outline text="#### 6.8.1)Dom4j"/>        </outline>        <outline text="### 6.9)配置文件"/>      </outline>      <outline text="## 7)算法与设计模式">        <outline text="### 7.1)设计模式">          <outline text="#### 7.1.1)GOF">            <outline text="##### 7.1.1.1)创建型">              <outline text="###### 7.1.1.1.1)Factory Method（工厂方法）"/>              <outline text="###### 7.1.1.1.2)Abstract Factory（抽象工厂）"/>              <outline text="###### 7.1.1.1.3)Builder（建造者）"/>              <outline text="###### 7.1.1.1.4)Prototype（原型）"/>              <outline text="###### 7.1.1.1.5)Singleton（单例）"/>            </outline>            <outline text="##### 7.1.1.2)结构型">              <outline text="###### 7.1.1.2.1)Adapter Class/Object（适配器）"/>              <outline text="###### 7.1.1.2.2)Bridge（桥接）"/>              <outline text="###### 7.1.1.2.3)Composite（组合）"/>              <outline text="###### 7.1.1.2.4)Decorator（装饰）"/>              <outline text="###### 7.1.1.2.5)Facade（外观）"/>              <outline text="###### 7.1.1.2.6)Flyweight（享元）"/>              <outline text="###### 7.1.1.2.7)Proxy（代理）"/>            </outline>            <outline text="##### 7.1.1.3)行为型">              <outline text="###### 7.1.1.3.1)Interpreter（解释器）"/>              <outline text="###### 7.1.1.3.2)Template Method（模板方法）"/>              <outline text="###### 7.1.1.3.3)Chain of Responsibility（责任链）"/>              <outline text="###### 7.1.1.3.4)Command（命令）"/>              <outline text="###### 7.1.1.3.5)Iterator（迭代器）"/>              <outline text="###### 7.1.1.3.6)Mediator（中介者）"/>              <outline text="###### 7.1.1.3.7)Memento（备忘录）"/>              <outline text="###### 7.1.1.3.8)Observer（观察者）"/>              <outline text="###### 7.1.1.3.9)State（状态）"/>              <outline text="###### 7.1.1.3.10)Strategy（策略）"/>              <outline text="###### 7.1.1.3.11)Visitor（访问者）"/>            </outline>          </outline>          <outline text="#### 7.1.2)六大原则">            <outline text="##### 7.1.2.1)1、开闭原则（Open Close Principle）"/>            <outline text="##### 7.1.2.2)2、里氏代换原则（Liskov Substitution Principle）"/>            <outline text="##### 7.1.2.3)3、依赖倒转原则（Dependence Inversion Principle）"/>            <outline text="##### 7.1.2.4)4、接口隔离原则（Interface Segregation Principle）"/>            <outline text="##### 7.1.2.5)5、迪米特法则（最少知道原则）（Demeter Principle）"/>            <outline text="##### 7.1.2.6)6、合成复用原则（Composite Reuse Principle）"/>          </outline>        </outline>        <outline text="### 7.2)算法">          <outline text="#### 7.2.1)算法（第四版）"/>        </outline>      </outline>      <outline text="## 8)项目"/>      <outline text="## 9)试题"/>      <outline text="## 0)文化"/>    </outline>  </body></opml><?xml version="1.0" encoding="UTF-8"?><opml>  <head>    <title></title>    <dateModified></dateModified>    <ownerName></ownerName>  </head>  <body>    <outline text="# Java" 栏2="第一行&#10;第二行&#10;第四行&#10;">      <outline text="#### 我就是四级菜单"/>      <outline text="## 1)环境">        <outline text="### Java简介"/>        <outline text="### JDK的安装与配置"/>        <outline text="### 1.1)命令" _note="参考文档：https://blog.csdn.net/yang889999888/article/details/72823261&#10;">          <outline text="#### 1.1.1)java" _note="运行java程序。&#10;"/>          <outline text="#### 1.1.2)javac" _note="编译的Java程序，生成.class文件。&#10;"/>          <outline text="#### 1.1.3)javaw" _note="跟java命令相对的，可以运行.class文件,主要用来执行图形界面的java程序运行java命令时，会出现并保持一个console窗口,程 序中的信息可以通过System.out在console内输出，而运行javaw，开始时会出现console，当主程序调用之后，console就会 消失； javaw 大多用来运行GUI程序。&#10;"/>          <outline text="#### 1.1.4)javah" _note="C 头文件和 Stub 文件生成器。javah 从 Java 类生成 C 头文件和 C 源文件。这些文件提供了连接胶合，使 Java 和 C 代码可进行交互。&#10;"/>          <outline text="#### 1.1.5)javap" _note="用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。&#10;"/>          <outline text="#### 1.1.6)jdb" _note="命令行调试环境，既可在本地，也可在与远程的解释器的一次对话中执行。&#10;"/>          <outline text="#### 1.1.7)javaws" _note="应用程序高速缓存查看器。&#10;"/>          <outline text="#### 1.1.8)jconsole" _note="Java监视和管理控制台,JConsole使用JVM的可扩展性Java管理扩展(JMX)工具来提供关于运行于Java平台的应用程序的性能和资源消耗的信息。&#10;"/>          <outline text="#### 1.1.9)jps" _note="java虚拟机进程状态工具---在目标系统上列出装备有HotSpot Java的虚拟机。&#10;"/>          <outline text="#### 1.1.10)jstat" _note="JVM监控工具,java虚拟机统计监视工具---附加到一个装备了HotSpot的java虚拟机上来采集并且记录性能统计情况。&#10;"/>          <outline text="#### 1.1.11)jstatd" _note="java虚拟机的jstat守护程序---启动一个RMI服务器程序来监视各个HotSpot java虚拟机的创建和中止。并且提供了一个访问远程监视工具接入的接口。&#10;"/>          <outline text="#### 1.1.12)kinit" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.13)klist" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.14)ktab" _note="Java安全管理工具，详见http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security。&#10;"/>          <outline text="#### 1.1.15)native2ascii" _note="将含有本地编码字符（既非 Latin1 又非 Unicode 字符）的文件转换为 Unicode 编码字符的文件。&#10;"/>          <outline text="#### 1.1.16)ordb"/>          <outline text="#### 1.1.17)idlj"/>          <outline text="#### 1.1.18)servertool"/>          <outline text="#### 1.1.19)tnameserv"/>          <outline text="#### 1.1.20)"/>        </outline>        <outline text="### 1.2)javadoc"/>        <outline text="### 1.3)IDE">          <outline text="#### 1.3.1)Eclipse"/>          <outline text="#### 1.3.2)IDEA"/>          <outline text="#### 1.3.3)NetBeans"/>        </outline>        <outline text="### 1.4)版本管理">          <outline text="#### 1.4.1)SVN"/>          <outline text="#### 1.4.2)Git"/>        </outline>      </outline>      <outline text="## 2)基础语法">        <outline text="### 2.1)数据类型">          <outline text="#### 2.1.1)数据类型清单">            <outline text="##### 2.1.1.1)整形/int"/>            <outline text="##### 2.1.1.2)浮点型/float"/>            <outline text="##### 2.1.1.3)字符型/char"/>            <outline text="##### 2.1.1.4)布尔型/boolean"/>          </outline>          <outline text="#### 2.1.2)标识符">            <outline text="##### 2.1.2.1)变量"/>            <outline text="##### 2.1.2.2)常量"/>          </outline>          <outline text="#### 2.1.3)关键字">            <outline text="##### 2.1.3.1)private" _note="&#10;| 关键字          | 同一个包中的其他类 | 不同包中的其他类 | 子类   | 自身   |&#10;| ------------ | --------- | -------- | ---- | ---- |&#10;| private      | No        | No       | No   | Yes  |&#10;| protected    | Yes       | No       | Yes  | Yes  |&#10;| public       | Yes       | Yes      | Yes  | Yes  |&#10;| 无修饰（default） | Yes       | No       | No   | Yes  |&#10;"/>            <outline text="##### 2.1.3.2)public"/>            <outline text="##### 2.1.3.3)protected"/>            <outline text="##### 2.1.3.4)default"/>            <outline text="##### 2.1.3.5)static" _note="&#10;static关键字修饰内容的几个特点：&#10;1. static修饰的变量和类文件一同被加载到内存中&#10;2. 被修饰的方法可以直接通过类名加点来引用，也就是说static修饰部分的引用是不需要将对象实例化的。&#10;    有关static一些**注意事项**：&#10;- static方法只能访问static变量&#10;- static方法中不能使用this,super这样的关键字，因为static优先于对象被加载到内存之中，static执行时对象可能还未被实例化。&#10;- 内部类包含static修饰的属性或方法时，内部类必须也被static修饰，其实理解起来也很简答，应为static会优先被加载，如果内部类不被static修饰，那么内部变量是不会被提前加载的，这时static关键字修饰就不起作用了。&#10;"/>            <outline text="##### 2.1.3.6)final" _note="&#10;- final是一个修饰词，可修饰类，变量，函数&#10;- final修饰的类不可被继承&#10;- final修饰的函数无法被复写&#10;- final修饰的变量只能赋值一次&#10;"/>            <outline text="##### 2.1.3.7)abstract" _note="&#10;- abstract能够修饰方法和类&#10;- abstract修饰的类无法被实例化，只能够通过子类的继承并实现内部所有的抽象函数才能被实例化。&#10;- abstract修饰的函数只需要申明方法名，参数，不需要写函数体。&#10;- 抽象类中同样可以定义非抽象的方法，同时抽象类也有构造函数，这个构造函数提供给子类实例化时使用。&#10;- 抽象类中也可以没有抽象的方法。&#10;- abstract不可以和static，private，final公用，简单理解一下，static修饰说明优先加载，而abstract未被实现，所以无法被优先加载。final修饰表名为最终状态无法修改，而abstract修饰的需要子类去实现，必须可以修改。private表示私有化，自由自身能够访问到，而abstract需要子类访问并实现函数体。&#10;"/>            <outline text="##### 2.1.3.8)instanceof" _note="用于判断类是否实现了指定接口或实现了指定的类，举个简单的例子：&#10;```java&#10;public class Test {&#10;    public static void main(String[] args) {&#10;        NullPointerException e = new NullPointerException();&#10;        System.out.println(e instanceof Exception);&#10;    }&#10;}&#10;//输出结果为true&#10;```&#10;"/>          </outline>          <outline text="#### 2.1.4)类型转换"/>          <outline text="#### 2.1.5)数组"/>          <outline text="#### 2.1.6)枚举"/>        </outline>        <outline text="### 2.2)运算操作">          <outline text="#### 2.2.1)表达式"/>          <outline text="#### 2.2.2)分隔符"/>          <outline text="#### 2.2.3)运算符"/>        </outline>        <outline text="### 2.3)语句控制">          <outline text="#### 2.3.1)循环语句"/>          <outline text="#### 2.3.2)条件语句"/>          <outline text="#### 2.3.3)跳转语句"/>          <outline text="#### 2.3.4)其他语句"/>        </outline>        <outline text="### 2.4)注释"/>        <outline text="### 2.5)修饰符"/>      </outline>      <outline text="## 3)常用基础类库">        <outline text="### 3.1)lang"/>        <outline text="### 3.2)collections"/>        <outline text="### 3.3)io"/>        <outline text="### 3.4)net"/>      </outline>      <outline text="## 4)OOP">        <outline text="### 4.1)OOP思想">          <outline text="#### 4.1.1)封装"/>          <outline text="#### 4.1.2)继承"/>          <outline text="#### 4.1.3)多态"/>        </outline>        <outline text="### 4.2)类与对象">          <outline text="#### 4.2.1)Object类"/>          <outline text="#### 4.2.2)Class类"/>          <outline text="#### 4.2.3)抽象类"/>          <outline text="#### 4.2.4)接口"/>          <outline text="#### 4.2.5)匿名内部类"/>          <outline text="#### 4.2.6)包装类"/>        </outline>        <outline text="### 4.3)类的行为">          <outline text="#### 4.3)构造方法"/>          <outline text="#### 4.3.1)重载(Overload)" _note="&#10;（1） 方法重载是让类以**统一的方式处理不同类型数据**的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。&#10;（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。&#10;（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。&#10;（4） 返回值是方法执行后的结果，我们在调用方法的时候不会指定说“我要调用返回值是xxx类型的方法”，它不成成为方法重载的特征。&#10;（5） 重载的标志：方法名相同，参数不同（个数或者类型），与返回值无关。&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，编译器多态。&#10;**重载的规则：**&#10;1、必须具有不同的参数列表；&#10;2、可以有不责骂的返回类型，只要参数列表不同就可以了；&#10;3、可以有不同的访问修饰符；&#10;4、可以抛出不同的异常；&#10;5、当需要在子类中调用父类的被重写方法时，要使用super关键字。&#10;```java&#10;public class OverloadParent{&#10;  public String getPerson(String name){&#10;    return “personA” + name;&#10;  }&#10;  public String getPerson(int age){&#10;    return “personB” ;&#10;  }&#10;  public String getPerson(String name,int age){&#10;    return “personC”;&#10;  }&#10;  public void getPerson(String name){&#10;    System.out.println(“我是重载的方法吗？”);&#10;  }&#10;}&#10;public class OverloadChildextends OverloadParent {&#10;  public void getPerson(double money){&#10;     Sytem.out.println(“我是重载的方法吗”);&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.2)覆写(Override)" _note="&#10;（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。&#10;但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。&#10;方法覆写又称方法覆盖。&#10;（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。&#10;（3）子类函数的访问修饰权限不能少于父类的；&#10;**应用场景**&#10;覆写：子类有自己特有的行为，从父类继承而不能满足自身需要时。多态的表现，运行期多态。&#10;**覆写方法的规则：**&#10;1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。&#10;2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。&#10;3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）&#10;4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：&#10;父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。&#10;覆写与重载的区别在于：&#10;覆写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。&#10;```java&#10;public class OverrideParent{&#10;   public void fly(){&#10;     System.out.println(“Ican fly!”);&#10;  }&#10;}&#10;public class OverrideChild extends OverrideParent{&#10;  @override&#10;  public void fly(){&#10;       System.out.println(“Ican not fly, but I can run!”);&#10;  }&#10;  public static vid main(String[] args){&#10;       OverwriteParent child= new OverwriteChild();&#10;       child.fly();&#10;  }&#10;}&#10;```&#10;"/>          <outline text="#### 4.3.3)泛型"/>          <outline text="#### 4.3.4)反射"/>        </outline>      </outline>      <outline text="## 5)高级语法">        <outline text="### 5.1)字符串">          <outline text="#### 5.1.1)String"/>          <outline text="#### 5.1.2)StringBuilder"/>          <outline text="#### 5.1.3)StringBuffer"/>        </outline>        <outline text="### 5.2)异常"/>        <outline text="### 5.3)集合">          <outline text="#### 5.3.1)List"/>          <outline text="#### 5.3.2)Set"/>          <outline text="#### 5.3.3)Map"/>          <outline text="#### 5.3.4)数组"/>        </outline>        <outline text="### 5.4)可变参数"/>        <outline text="### 5.5)静态导入"/>        <outline text="### 5.6)Annotation"/>        <outline text="### 5.7)Lambda"/>        <outline text="### 5.8)正则表达式">          <outline text="#### 5.8.1)Regex"/>        </outline>        <outline text="### 5.9)JDBC">          <outline text="#### 5.9.1.)JDBC基础"/>          <outline text="#### 5.9.2)连接池技术"/>          <outline text="#### 5.9.3)jdbc的dao封装"/>        </outline>        <outline text="### 5.10)JVM">          <outline text="#### 5.10.1)内存"/>          <outline text="#### 5.10.2)GC"/>        </outline>        <outline text="### 5.11)多线程">          <outline text="#### 5.11.1)线程池"/>          <outline text="#### 5.11.2)线程安全集合"/>          <outline text="#### 5.11.3)线程锁"/>        </outline>        <outline text="### 5.12)国际化">          <outline text="#### 5.12.1)字符集"/>        </outline>        <outline text="### 5.13)比较器"/>        <outline text="### 5.14)文件与流">          <outline text="#### 5.14.1)文件操作类"/>          <outline text="#### 5.14.2)字节流与字符流">            <outline text="##### 5.14.2.1)文件的读入"/>            <outline text="##### 5.14.2.1.1)按字节读取文件内容" _note="```java&#10;public static void readFileByBytes(String fileName) {&#10;    File file = new File(fileName);&#10;    InputStream in = null;&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);&#10;        // 一次读一个字节&#10;        in = new FileInputStream(file);&#10;        int tempbyte;&#10;        while ((tempbyte = in.read()) != -1) {&#10;            System.out.write(tempbyte);&#10;        }&#10;        in.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;        return;&#10;    }&#10;    try {&#10;        System.out.println(&quot;以字节为单位读取文件内容，一次读多个字节：&quot;);&#10;        // 一次读多个字节&#10;        byte[] tempbytes = new byte[100];&#10;        int byteread = 0;&#10;        in = new FileInputStream(fileName);&#10;        ReadFromFile.showAvailableBytes(in);&#10;        // 读入多个字节到字节数组中，byteread为一次读入的字节数&#10;        while ((byteread = in.read(tempbytes)) != -1) {&#10;            System.out.write(tempbytes, 0, byteread);&#10;        }&#10;    } catch (Exception e1) {&#10;        e1.printStackTrace();&#10;    } finally {&#10;        if (in != null) {&#10;            try {&#10;                in.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;private static void showAvailableBytes(InputStream in) {&#10;    try {&#10;        System.out.println(&quot;当前字节输入流中的字节数为:&quot; + in.available());&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.2)按字符读取文件内容" _note="```java&#10;public static void readFileByChars(String fileName) {&#10;     File file = new File(fileName);&#10;     Reader reader = null;&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读一个字节：&quot;);&#10;         // 一次读一个字符&#10;         reader = new InputStreamReader(new FileInputStream(file));&#10;         int tempchar;&#10;         while ((tempchar = reader.read()) != -1) {&#10;             // 对于windows下，\r\n这两个字符在一起时，表示一个换行。&#10;             // 但如果这两个字符分开显示时，会换两次行。&#10;             // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。&#10;             if (((char) tempchar) != '\r') {&#10;                 System.out.print((char) tempchar);&#10;             }&#10;         }&#10;         reader.close();&#10;     } catch (Exception e) {&#10;         e.printStackTrace();&#10;     }&#10;     try {&#10;         System.out.println(&quot;以字符为单位读取文件内容，一次读多个字节：&quot;);&#10;         // 一次读多个字符&#10;         char[] tempchars = new char[30];&#10;         int charread = 0;&#10;         reader = new InputStreamReader(new FileInputStream(fileName));&#10;         // 读入多个字符到字符数组中，charread为一次读取字符数&#10;         while ((charread = reader.read(tempchars)) != -1) {&#10;             // 同样屏蔽掉\r不显示&#10;             if ((charread == tempchars.length) &amp;&amp; (tempchars[tempchars.length - 1] != '\r')) {&#10;                  System.out.print(tempchars);&#10;             } else {&#10;                 for (int i = 0; i &lt; charread; i++) {&#10;                     if (tempchars[i] == '\r') {&#10;                         continue;&#10;                     } else {&#10;                         System.out.print(tempchars[i]);&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (Exception e1) {&#10;         e1.printStackTrace();&#10;     } finally {&#10;         if (reader != null) {&#10;             try {&#10;                 reader.close();&#10;             } catch (IOException e1) {&#10;             }&#10;         }&#10;     }&#10; }&#10;```&#10;"/>            <outline text="##### 5.14.2.1.3)按行读取文件内容" _note="```java&#10;public static void readFileByLines(String fileName) {&#10;    File file = new File(fileName);&#10;    BufferedReader reader = null;&#10;    try {&#10;        System.out.println(&quot;以行为单位读取文件内容，一次读一整行：&quot;);&#10;        reader = new BufferedReader(new FileReader(file));&#10;        String tempString = null;&#10;        int line = 1;&#10;        // 一次读入一行，直到读入null为文件结束&#10;        while ((tempString = reader.readLine()) != null) {&#10;            // 显示行号&#10;            System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);&#10;            line++;&#10;        }&#10;        reader.close();&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (reader != null) {&#10;            try {&#10;                reader.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.1.4)随机读取文件内容" _note="```java&#10;public static void readFileByRandomAccess(String fileName) {&#10;    RandomAccessFile randomFile = null;&#10;    try {&#10;        System.out.println(&quot;随机读取一段文件内容：&quot;);&#10;        // 打开一个随机访问文件流，按只读方式&#10;        randomFile = new RandomAccessFile(fileName, &quot;r&quot;);&#10;        // 文件长度，字节数&#10;        long fileLength = randomFile.length();&#10;        // 读文件的起始位置&#10;        int beginIndex = (fileLength &gt; 4) ? 4 : 0;&#10;        // 将读文件的开始位置移到beginIndex位置。&#10;        randomFile.seek(beginIndex);&#10;        byte[] bytes = new byte[10];&#10;        int byteread = 0;&#10;        // 一次读10个字节，如果文件内容不足10个字节，则读剩下的字节。&#10;        // 将一次读取的字节数赋给byteread&#10;        while ((byteread = randomFile.read(bytes)) != -1) {&#10;            System.out.write(bytes, 0, byteread);&#10;        }&#10;    } catch (IOException e) {&#10;        e.printStackTrace();&#10;    } finally {&#10;        if (randomFile != null) {&#10;            try {&#10;                randomFile.close();&#10;            } catch (IOException e1) {&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;"/>            <outline text="##### 5.14.2.2)文件的写入"/>            <outline text="##### 5.14.2.2.1)FileWritter写入文件" _note="```java&#10;public static void main( String[] args ){&#10;　　   try{&#10;　　         String data = &quot; This content will append to the end of the file&quot;;&#10;　　         File file =new File(&quot;javaio-appendfile.txt&quot;);&#10;　　         //if file doesnt exists, then create it&#10;　　         if(!file.exists()){&#10;　　              file.createNewFile();&#10;　　          }&#10;　　         //true = append file&#10;　　         FileWriter fileWritter = new FileWriter(file.getName(),true);&#10;　　         BufferedWriter bufferWritter = new BufferedWriter(fileWritter);&#10;　　         bufferWritter.write(data);&#10;　　         bufferWritter.close();&#10;　　         System.out.println(&quot;Done&quot;);&#10;　　   }catch(IOException e){&#10;　　        e.printStackTrace();&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.2)BufferedWriter写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    try {&#10;　　        String content = &quot;This is the content to write into file&quot;;&#10;　　        File file = new File(&quot;/users/mkyong/filename.txt&quot;);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　           file.createNewFile();&#10;　　       }&#10;　　       FileWriter fw = new FileWriter(file.getAbsoluteFile());&#10;　　       BufferedWriter bw = new BufferedWriter(fw);&#10;　　       bw.write(content);&#10;　　       bw.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　    } catch (IOException e) {&#10;　　         e.printStackTrace();&#10;　　    }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.3)FileOutputStream写入文件" _note="```java&#10;public static void main(String[] args) {&#10;　　    FileOutputStream fop = null;&#10;　　    File file;&#10;　　    String content = &quot;This is the text content&quot;;&#10;　　    try {&#10;　　        file = new File(&quot;c:/newfile.txt&quot;);&#10;　　        fop = new FileOutputStream(file);&#10;　　       // if file doesnt exists, then create it&#10;　　       if (!file.exists()) {&#10;　　            file.createNewFile();&#10;　　       }&#10;　　       // get the content in bytes&#10;　　       byte[] contentInBytes = content.getBytes();&#10;　　       fop.write(contentInBytes);&#10;　　       fop.flush();&#10;　　       fop.close();&#10;　　       System.out.println(&quot;Done&quot;);&#10;　　   } catch (IOException e) {&#10;　　       e.printStackTrace();&#10;　　   } finally {&#10;　　       try {&#10;　　           if (fop != null) {&#10;　　               fop.close();&#10;　　           }&#10;　　       } catch (IOException e) {&#10;　　             e.printStackTrace();&#10;　　       }&#10;　　   }&#10;　　}&#10;```&#10;"/>            <outline text="##### 5.14.2.2.4)几种方法的比较" _note="相对而言，FileWritter最快，FileOutputStream最慢&#10;"/>          </outline>        </outline>        <outline text="### 5.15)序列化"/>      </outline>      <outline text="## 6)开源专题">        <outline text="### 6.1)Log">          <outline text="#### 6.1.1)Log4j"/>          <outline text="#### 6.1.2)SLF4J"/>        </outline>        <outline text="### 6.2)ORM">          <outline text="#### 6.2.1)Hibernate"/>          <outline text="#### 6.2.2)MyBatis">            <outline text="##### 6.2.2.1)1.mybatis简介"/>            <outline text="##### 6.2.2.2)2.基本增删改查"/>            <outline text="##### 6.2.2.3)3.注解方式实现"/>            <outline text="##### 6.2.2.4)4.动态SQL"/>            <outline text="##### 6.2.2.5)5.多种参数传递"/>            <outline text="##### 6.2.2.6)6.一对一"/>            <outline text="##### 6.2.2).77.一对多"/>            <outline text="##### 6.2.2.8)8.多对多"/>          </outline>        </outline>        <outline text="### 6.3)Test">          <outline text="#### 6.3.1)JUnit"/>        </outline>        <outline text="### 6.4)Build">          <outline text="#### 6.4.1)Ant"/>          <outline text="#### 6.4.2)Maven"/>          <outline text="#### 6.4.3)Gradle"/>        </outline>        <outline text="### 6.5)脚本语言">          <outline text="#### 6.5.1)Groovy"/>          <outline text="#### 6.5.2)velocity"/>        </outline>        <outline text="### 6.6)Spring">          <outline text="#### 6.6.1)SpringCore">            <outline text="##### 6.6.1.2)01.了解Spring"/>            <outline text="##### 6.6.1.2)02.IOC思想"/>            <outline text="##### 6.6.1.3)03.DI依赖注入"/>            <outline text="##### 6.6.1.4)04.控制反转"/>            <outline text="##### 6.6.1.5)05.代理"/>            <outline text="##### 6.6.1.6)06.事务管理"/>            <outline text="##### 6.6.1.7)07.Bean生命周期"/>            <outline text="##### 6.6.1.8)08.集合注入"/>            <outline text="##### 6.6.1.9)09.AOP概念"/>            <outline text="##### 6.6.1.10)10.Spring注解"/>          </outline>          <outline text="#### 6.6.2)SpringMVC">            <outline text="##### 6.6.2.1)SpringMVC简介"/>            <outline text="##### 6.6.2.2)handleMapping"/>            <outline text="##### 6.6.2.3)RequestMapping"/>            <outline text="##### 6.6.2.4)SpringMVC参数传递"/>            <outline text="##### 6.6.2.5)返回页面数据"/>            <outline text="##### 6.6.2.6)适配器"/>            <outline text="##### 6.6.2.7)拦截器"/>            <outline text="##### 6.6.2.8)视图与模型"/>            <outline text="##### 6.6.2.9)上传文件"/>            <outline text="##### 6.6.2.10)AJAX的使用"/>            <outline text="##### 6.6.2.11)SpringMVC与Struts区别"/>          </outline>          <outline text="#### 6.6.3)SpringBoost"/>        </outline>        <outline text="### 6.7)前端技术"/>        <outline text="### 6.8)XML">          <outline text="#### 6.8.1)Dom4j"/>        </outline>        <outline text="### 6.9)配置文件"/>      </outline>      <outline text="## 7)算法与设计模式">        <outline text="### 7.1)设计模式">          <outline text="#### 7.1.1)GOF">            <outline text="##### 7.1.1.1)创建型">              <outline text="###### 7.1.1.1.1)Factory Method（工厂方法）"/>              <outline text="###### 7.1.1.1.2)Abstract Factory（抽象工厂）"/>              <outline text="###### 7.1.1.1.3)Builder（建造者）"/>              <outline text="###### 7.1.1.1.4)Prototype（原型）"/>              <outline text="###### 7.1.1.1.5)Singleton（单例）"/>            </outline>            <outline text="##### 7.1.1.2)结构型">              <outline text="###### 7.1.1.2.1)Adapter Class/Object（适配器）"/>              <outline text="###### 7.1.1.2.2)Bridge（桥接）"/>              <outline text="###### 7.1.1.2.3)Composite（组合）"/>              <outline text="###### 7.1.1.2.4)Decorator（装饰）"/>              <outline text="###### 7.1.1.2.5)Facade（外观）"/>              <outline text="###### 7.1.1.2.6)Flyweight（享元）"/>              <outline text="###### 7.1.1.2.7)Proxy（代理）"/>            </outline>            <outline text="##### 7.1.1.3)行为型">              <outline text="###### 7.1.1.3.1)Interpreter（解释器）"/>              <outline text="###### 7.1.1.3.2)Template Method（模板方法）"/>              <outline text="###### 7.1.1.3.3)Chain of Responsibility（责任链）"/>              <outline text="###### 7.1.1.3.4)Command（命令）"/>              <outline text="###### 7.1.1.3.5)Iterator（迭代器）"/>              <outline text="###### 7.1.1.3.6)Mediator（中介者）"/>              <outline text="###### 7.1.1.3.7)Memento（备忘录）"/>              <outline text="###### 7.1.1.3.8)Observer（观察者）"/>              <outline text="###### 7.1.1.3.9)State（状态）"/>              <outline text="###### 7.1.1.3.10)Strategy（策略）"/>              <outline text="###### 7.1.1.3.11)Visitor（访问者）"/>            </outline>          </outline>          <outline text="#### 7.1.2)六大原则">            <outline text="##### 7.1.2.1)1、开闭原则（Open Close Principle）"/>            <outline text="##### 7.1.2.2)2、里氏代换原则（Liskov Substitution Principle）"/>            <outline text="##### 7.1.2.3)3、依赖倒转原则（Dependence Inversion Principle）"/>            <outline text="##### 7.1.2.4)4、接口隔离原则（Interface Segregation Principle）"/>            <outline text="##### 7.1.2.5)5、迪米特法则（最少知道原则）（Demeter Principle）"/>            <outline text="##### 7.1.2.6)6、合成复用原则（Composite Reuse Principle）"/>          </outline>        </outline>        <outline text="### 7.2)算法">          <outline text="#### 7.2.1)算法（第四版）"/>        </outline>      </outline>      <outline text="## 8)项目"/>      <outline text="## 9)试题"/>      <outline text="## 0)文化"/>    </outline>  </body></opml>